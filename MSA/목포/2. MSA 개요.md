# MSA 개요

[image:C7EF7110-1D05-43BE-855C-972C807DAF3C-54871-000008F772854727/가트너MSAComponent.png]
MSA는 크게 **Inner Architecture** 와 **Outer Architecture**로 구분할 수 있다.

## Inner Architecture

[image:6C93E5F6-2F84-43F2-9CAF-B75F2FB23E4E-54871-000008F7C106EAB7/Inner.PNG.png]
1번 문서에서 설명한대로 각 서비스대로 모듈을 개발하기 때문에 그 서비스에 적합한 DB, API 설계 등이 다 다르다. (표준이 없다.)
특히 서비스를 어떻게 정의할 것인지는 비즈니스뿐만이 아니라, 서비스 간의 종속성, 배포 용이성, 장애 대응, 운영 효율성 등 고려해야할 것이 많기 때문에 이것이 정답이다 말할 수 없다.

## Outer Architecture

Gartner에서는 MSA의 Outer Architecture를 총 6개의 영역으로 분류하고 있다.

### 1. External Gateway

앞에서 설명했듯이 MSA 구현은 애플리케이션에서 사용할 수 있는 `API형태로 기능을 노출`할 수 있다. External Gateway는 전체 서비스 외부로부터 들어오는 접근을 내부 구조를 드러내지 않고 처리하기 위한 요소이다. 이런 서비스에 대한 엑세스를 관리하고 트래픽 관리, 사용자 인증 및 보안 정책을 적용하여 마이크로 서비스 환경을 보호할 수 있다.
API Gateway는 서버 최앞단에 위치하며 모든 API 호출을 받는다. 그 후 적절한 서비스들에게 메세지를 전달한다.(Routing)

### 2. Service Mesh

Service Mesh는 마이크로서비스 **구성 요소 간 네트워크를 제어하는 역할**을 한다. 서비스 간 통신을 위해서는 Service Discovery, Service Routing, 트래픽 관리 및 보안 등을 담당하는 요소가 있어야 한다.

- **Service Routing** : 클라이언트 응용 프로그램에서 또는 마이크로 서비스 사이의 요청은 구성 및 정책에 따라 올바른 마이크로 서비스로 라우팅해야한다.
- **Load Balancing** : 각 마이크로 서비스의 인스턴스 확장성을 지원하기 위해 로드밸런싱이 필요하며 밸런싱의 세밀성 및 구성은 각 서비스를 관리하는 팀에 의해 제어되어야 한다.
- **Service Discovery** : 서비스는 느슨하게 결합된 방식으로 검색 가능해야한다. 서비스 검색은 일반적으로 서비스 레지스트리를 사용하여 구현되며, 이 서비스 레지스트리에서 마이크로 서비스 소유자는 런타임에 다른 서비스가 필요로하는 정보를 등록 및 구성하여 찾아 호출할 수 있다. 네트워크 수준의 DNS와 유사하게 생각할 수 있다. 또, 이것은 마이크로 서비스 간 존재할 종속성을 관리하는데 도움을 주며 환경 변화를 관리하는데 중요하다.
- **구성 저장소** : 서비스 인스턴스는 마이크로 서비스와 전체 환경과 관련된 구성을 공유해야한다. 예를들어, 환경에 배포 된 마이크로 서비스에는 서비스 검색 레지스트리의 위치와 로그 이벤트를 내보내는 위치를 파악하는 방법이 필요하다. 마이크로 서비스 환경의 분산 특성으로 인해 분산 키-값 저장소를 사용하여 구현되는 경우가 많다.
- **ID Provider** : 서비스 인스턴스는 신뢰할 수 있는 ID를 사용하여 통신해야한다. 서비스 메시는 이러한 ID를 제공하고 유효성을 검사한다.

### 3. Container Management

컨테이너 기반 어플리케이션 운영은 유연성과 자율성을 가지며, 개발자가 손쉽게 접근 및 운영할 수 있는 인프라 관리 기술이다.

- 스케줄링 : 컨테이너 클러스터 내부에서 컨테이너를 프로비저닝 가능
- 구성 스크립팅 : 특정 애플리케이션 구성정보를 사전에 YAML, JSON 으로 스크립팅하여 이에 대한 정보를 기반으로 컨테이너를 로드 가능
- 모니터링 : 컨테이너 상태를 모니터링하여, 컨테이너가 다운되는 경우 새로운 컨테이너를 스핀업 가능
- 업그레이드와 롤백 : 새 버전의 컨테이너 또는 컨테이너 내부에서 구동하는 애플리케이션을 배포할 때, 컨테이너 오케스트레이션은 컨테이너 클러스터 전체를 대상으로 자동 업데이트 및 롤백 처리 가능
- 서비스 디스커버리, 로드밸런싱 : 특정 컨테이너가 어느 호스트에서 실행되는지 찾을 수 있으며, 특정 컨테이너에만 부하가 집중되는 것을 방지하기 위한 로드밸런싱 기능이 존재
- 컨테이너 오토스케일링 : 인프라 전반에 애플리케이션 로드를 고르게 분산시키기 위해 자동으로 컨테이너 확장 및 제거

### 4. Backing Service

[image:655659EB-58A7-48E2-BA3F-6E90EECB7F2F-54871-00000900E756CF5B/messagequeue.png]
애플리케이션이 실행되는 가운데 네트워크 통해서 사용할 수 있는 모든 서비스를 말하며, MySQL과 같은 데이터베이스, 캐시 시스템, SMTP 서비스 등 애플리케이션과 통신하는 attached Resource들을 지칭하는 포괄적 개념이다.
MSA에서 가장 특징적인 Backing Service들 중 하나는 Message Queue이다. MSA에서는 메세지의 송신자와 수신자가 직접 통신하지 않고 Message Queue를 활용하여 비동기적으로 통신하는 것을 지향한다.
만약 Message Queue를 사용하지 않는 강한 결합 구조의 경우, 여러 서비스를 걸치는 실시간 트랜잭션을 처리할 때, 하나의 서비스가 죽어버린다면 트랜잭션이 끊어지기 때문에 해당 서비스 요청을 보존할 수 없고 큰 에러가 발생하게 된다. 또한 REST 통신으로 트랜잭션 실패에 대한 처리를 구현하는 방법은 굉장히 복잡하다.
MSA에서 데이터 변경이나, 보상 트랜잭션과 관련된 처리는 Message Queue를 활용한 비동기 처리가 효율적이다.

- **Message Queue란?**
  일반적인 웹서비스에서 서버-클라이언트 사이의 통신은 결합도가 높은 구조이며, 동기방식으로 작동한다.(클라이언트가 요청하면 서버는 그것을 처리한 후에 응답) 이와 같은 방식은 시스템 내 요소들 간에 의존성이 높아 시스템에 많은 영향을 끼치며, 유연성이 낮다.
  MQ는 메세지를 발행하는 생산자와 메세지를 받는 소비자 사이에 위치하는 매개체 역할을 수행하는 미들웨어이다.
  만약 다른 컴포넌트가 메세지를 검색하고 이를 사용해 어떤 작업을 수행할 때까지 메세지 큐에 저장된다. 각 메세지는 하나의 소비자에 의해 한 번만 처리될 수 있는데 이러한 이유로 메세지큐를 이용하는 방식을 일대일 통신이라고 부른다.
  [image:9DC1C4B8-1D0F-45E1-9020-AF5E2FC9F308-54871-000009043E425831/img.png]
  메세지큐는 소비자가 어느 시점에 메세지를 가져가 처리하는지 보장하지 않기 때문에 실패하면 치명적인 작업보단 애플리케이션의 부가적 기능에 사용하는 것이 적합하다.

### 5. Telemetry

서비스 별로 발생하는 이슈들을 Tracing 하기 위해 모니터링, 로깅, Tracer 도구를 활용하여 지속적, 자동적으로 이슈에 대응할 수 있도록 환경을 구성하는 것을 말한다.

### 6. CI/CD Automation

CI/CD는 애플리케이션 개발 단계를 자동화하여, 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법이다.
지속적 통합, 지속적 전달, 지속적 배포는 CI/CD의 기본 개념으로, 이를 자동화하는 것은 배포가 잦은 MSA 시스템에 꼭 필요한 요소 중 하나이다.
