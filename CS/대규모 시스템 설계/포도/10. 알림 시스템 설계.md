# 알림 시스템 설계

## 설계 범위 확정

- 푸시 알림, SMS 메시지, 이메일 알림을 지원해야 한다.
- 연성 실시간 시스템이라고 가정한다. 
- iOS, 안드로이드, 랩톱/데스크톱을 지원해야 한다.
- 사용자가 알림을 받지 않도록 설정할 수 있어야 한다.
- 하루에 천만 건의 모바일 푸시 알림, 백만 건의 SMS 메시지, 오백만건의 이메일을 보낼 수 있어야 한다.

<br>



## 개략적 설계안

### 알림 유형별 지원 방안

각각의 알림 매커니즘은 다음과 같이 동작한다.

<br>

#### iOS 푸시 알림

iOS에서 푸시 알림을 보내기 위해서는 다음 세 가지 컴포넌트가 필요하다.

- 알림 제공자 : 알림 요청을 만들어 애플 푸시 알림 서비스(APNS)로 보내는 주체이다. 알림 요청을 만들기 위해서는 다음과 같은 데이터가 필요하다.

  - 단말 토큰 : 알림 요청을 보내는 데 필요한 고유 식별자이다.

  - 페이로드 : 알림 내용을 담은 JSON 딕셔너리이다. 

    ```json
    {
    	"aps": {
            "alert": {
                "title": "GAME REQUEST",
                "body": "Bob wants to play chess",
                "action-loc-key": "PLAY" 
            },
            "badge": 5
        }
    }
    ```

- APNS : 애플이 제공하는 원격 서비스이다. 푸시 알림을 iOS 장치로 보내는 역할을 한다.

- iOS 단말 : 푸시 알림을 수신하는 사용자 단말

<br>



#### 안드로이드 푸시 알림

안드로이드의 경우도 iOS와 비슷하지만, APNS 대신 FCM(Firebase Cloud Messaging)을 사용한다.

<br>



#### SMS 메시지

SMS 메시지를 보낼 때는 보통 트윌리오, 넥스모 같은 제3 사업자의 서비스를 많이 이용한다.

<br>



#### 이메일

상용 이메일 서비스를 주로 이용하며, 그중 유명한 서비스로 샌드그리드, 메일침프가 있다. 전송 성공률도 높고, 데이터 분석 서비스도 제공한다.

<br>



![알림 유형](https://github.com/fe-docker-study/cs-study-for-interview/blob/main/CS/%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/%ED%8F%AC%EB%8F%84/%EC%82%AC%EC%A7%84/%EC%95%8C%EB%A6%BC%20%EC%9C%A0%ED%98%95.png)

<br>



### 연락처 정보 수집 절차

알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다. 

사용자가 앱을 설치하거나 처음으로 계정을 등록하면 API 서버는 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.

한 사용자가 여러 단말을 가질 수 있고, 알림은 모든 단말에 전송되어야 하기 때문에 이메일 주소와 전화번호는 user 테이블에 저장하고, 단말 토큰은 device 테이블에 저장한다.

<br>



### 알림 전송 및 수신 절차

#### 개략적 설계안 (초안)

![개략적 설계안 초안](https://github.com/fe-docker-study/cs-study-for-interview/blob/main/CS/%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/%ED%8F%AC%EB%8F%84/%EC%82%AC%EC%A7%84/%EA%B0%9C%EB%9E%B5%EC%A0%81%20%EC%84%A4%EA%B3%84%EC%95%88%20%EC%B4%88%EC%95%88.png)

- 1부터 N까지의 서비스 : 해당 서비스 각각은 마이크로서비스, 크론잡, 분산 시스템 컴포넌트 등일 수 있다. 
- 알림 시스템 : 알림 시스템은 서비스 1~N에 알림 전송을 위한 API를 제공해야 하고, 제3자 서비스에 전달할 알림 페이로드를 만들어낼 수 있어야 한다.
- 제3자 서비스 : 사용자에게 알림을 실제로 전달하는 역할을 한다. 제3자 서비스와의 통합을 진행할 때 유의할 것은 확장성이다. 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다. 또한 어떤 서비스는 다른 시장에서 사용할 수 있다는 것 또한 염두에 두어야 한다. (ex. FCM은 중국에서 사용 불가능)
- iOS, 안드로이드, SMS, 이메일 단말 : 사용자는 자기 단말에서 알림을 수신한다.

<br>

해당 설계의 문제점

- SPOF : 알림 서비스에 서버가 하나밖에 없는 경우 서버에 장애가 생기면 전체 서비스의 장애로 이어진다.
- 규모 확장성 : 한 대 서비스로 푸시 알림에 관계된 모든 것을 처리하기 때문에 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.
- 성능 병목 : 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업일 수 있다. 따라서 모든 것을 한 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.

<br>



#### 개략적 설계안 (개선 후)

- 데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리한다.
- 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어질 수 있도록 한다.
- 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.

<br>

![개략적 설계안 개선 후](https://github.com/fe-docker-study/cs-study-for-interview/blob/main/CS/%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/%ED%8F%AC%EB%8F%84/%EC%82%AC%EC%A7%84/%EA%B0%9C%EB%9E%B5%EC%A0%81%20%EC%84%A4%EA%B3%84%EC%95%88%20%EA%B0%9C%EC%84%A0%20%ED%9B%84.png)

- 1부터 N까지의 서비스 : 알림 시스템 서버의 API를 통해 알림을 보낼 서비스
- 알림 서버 : 다음 기능을 제공
  - 알림 전송 API : 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능하다.
  - 알림 검증 : 이메일 주소, 전화번호 등에 대한 기본적 검증을 수행한다.
  - 데이터베이스 또는 캐시 질의 : 알림에 포함시킬 데이터를 가져오는 기능이다.
  - 알림 전송 : 알림 데이터를 메시지 큐에 넣는다. 해당 설계안의 경우 하나 이상의 메시지 큐를 사용하므로 알림을 병렬적으로 처리할 수 있다.
- 캐시 : 사용자 정보, 단말 정보, 알림 템플릿 등을 캐시한다.
- 데이터베이스 : 사용자 알림 설정 등 다양한 정보를 저장한다.
- 메시지 큐 : 시스템 컴포넌트 간 의존성을 제거하기 위해 사용한다. 다양한 알림이 전송되어야 하는 경우를 대비한 버퍼 역할도 한다. 본 설계안에서는 알림의 종류별로 별도 메시지 큐를 사용하여 하나에 장애가 발생해도 다른 종류의 알림은 정상 작동한다.
- 작업 서버 : 메시지 큐에서 전송할 알림을 꺼내서 제3자 서비스로 전달하는 역할을 담당한다.

<br>



알림 전송 절차

1. API를 호출하여 알림 서버로 알림을 보낸다.
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위한 큐에 넣는다.
4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
5. 작업 서버는 알림을 제3자 서비스로 보낸다.
6. 제3자 서비스는 사용자 단말로 알림을 전송한다.

<br>



## 상세 설계

### 안정성

안정성 확보를 위해 다음 사항을 고려해야 한다.

<br>



#### 데이터 손실 방지

알림 시스템은 알림 데이터를 데이터베이스에 보관하고 재시도 매커니즘을 구현해야 한다. 알림 로그 데이터베이스를 유지하는 것이 하나의 방법이다.

<br>



#### 알림 중복 전송 방지

중복을 탐지하는 매커니즘을 도입하고 오류를 신중하게 처리해야 한다. 보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 중복된 이벤트인지 살피는 방식으로 중복을 방지할 수 있다.

<br>



### 추가 컴포넌트

#### 알림 템플릿

알림 메시지의 유사성을 고려하여 지정한 형식에 맞춰 알림을 만든다. 

<br>



#### 알림 설정

사용자가 알림 설정을 상세히 조정할 수 있도록 해야 한다. 해당 설정 도입 후에는 알림을 보내기 전 사용자가 알림을 켜 두었는지 확인해야 한다.

<br>



#### 전송률 제한

사용자가 받을 수 있는 알림의 빈도를 제한하여 너무 많은 알림을 보내지 않도록 한다.

<br>



#### 재시도 방법

제3자 서비스가 알림 전송에 실패하면 해당 알림을 재시도 전용 큐에 넣는다. 같은 문제가 계속 발생하면 개발자에게 통지한다.

<br>



#### 푸시 알림과 보안

iOS와 안드로이드 앱의 경우 알림 전송 API는 appKey와 appSecret을 사용하여 보안을 유지한다. 따라서 인증/승인된 클라이언트만 해당 API를 사용하여 알림을 보낼 수 있다.

<br>



#### 큐 모니터링

알림 시스템 모니터링 시 중요한 메트릭 하나는 큐에 쌓인 알림의 개수이다. 이 수가 너무 크면 작업 서버들이 이벤트를 빠르데 처리하고 있지 못하다는 뜻이다. 이 경우 작업 서버를 증설하는 것이 바람직하다.

<br>



#### 이벤트 추적

사용자를 이해하기 위해 데이터 분석 서비스는 이벤트 추적 기능도 제공해야 한다.

<br>



### 최종 설계안

![최종 설계안](https://github.com/fe-docker-study/cs-study-for-interview/blob/main/CS/%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/%ED%8F%AC%EB%8F%84/%EC%82%AC%EC%A7%84/%EC%B5%9C%EC%A2%85%20%EC%84%A4%EA%B3%84%EC%95%88.png)

- 알림 서버에 인증과 전송률 제한 기능 추가

- 전송 실패에 대응하기 위한 재시도 기능 추가

  전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도한다.

- 전송 템플릿을 사용하여 생성 과정 단순화 및 내용의 일관성 유지

- 모니터링과 추적 시스템 추가

<br>
