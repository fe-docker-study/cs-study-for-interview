# 분산 시스템을 위한 유일 ID 생성기 설계

'auto_increment' 속성이 설정된 관계형 DB의 기본 키의 경우 분산 환경에서 사용하면 지연 시간을 낮추기가 매우 어렵다. 따라서 분산 시스템에서 유일 ID를 사용하려면 별도의 설계가 필요하다.

<br>



## 설계 요구사항

- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10000개의 ID를 만들 수 있어야 한다.

<br>



## 다중 마스터 복제

다중 마스터 복제는 다음과 같은 구성을 가진다.

![다중 마스터 복제](https://github.com/fe-docker-study/cs-study-for-interview/blob/main/CS/%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/%ED%8F%AC%EB%8F%84/%EC%82%AC%EC%A7%84/%EB%8B%A4%EC%A4%91%20%EB%A7%88%EC%8A%A4%ED%84%B0%20%EB%B3%B5%EC%A0%9C.png)

다중 마스터 복제는 데이터베이스의 auto_increment 기능을 활용한다. 1씩 증가하는 기존 auto_increment와는 다르게 다음 ID 값을 구할 때 사용 중인 데이터베이스 서버의 수만큼 증가시킨다. 데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있기 때문에 규모 확장성 문제를 어느 정도 해결할 수 있다.

<br>

다중 마스터 복제의 단점

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.

- ID의 유일성은 보장되나, 그 값이 시간 흐름에 맞춰 커지도록 보장할 수는 없다.

  A, B 두 개의 데이터베이스가 있을 때 A에서 먼저 10개의 ID를 생성하고 B에서 ID를 생성하는 경우 A의 10번째 ID가 더 크지만, B의 ID가 더 최신이다. 따라서 시간의 흐름을 반영하지 못한다.

- 서버의 수를 변경해도 잘 동작하도록 만들기 어렵다.

<br>



## UUID

UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수이다. UUID 값은 충돌 가능성이 낮다. 따라서 유일성이 보장된 ID를 만드는 간단한 방법이 될 수 있다. 서버 간 조율 없이 독립적으로 생성 가능하다.

<br>

UUID의 장점

- 서버 사이의 조율이 필요 없기 때문에 동기화 이슈가 없어 단순하다.
- 규모 확장이 쉽다.

<br>

UUID의 단점

- ID가 128비트로 길다. (요구사항 : 64비트)
- ID를 시간 순으로 정렬할 수 없다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

<br>



## 티켓 서버

auto_increment 기능을 갖춘 데이터베이스 서버를 티켓 서버로 설정하여 중앙 집중형으로 하나만 사용하는 방법이다. 유일성이 보장된 ID를 생성할 수 있다.

<br>

티켓 서버의 장점

- 유일성이 보장되고 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현이 쉽고 중소 규모 애플리케이션에 적합하다.

<br>

티켓 서버의 단점

- 티켓 서버에 장애가 발생하면 해당 서버를 이용하는 모든 시스템이 영향을 받게 된다. (SPOF) 

  해당 이슈를 피하려면 티켓 서버를 여러 대 준비해야 되는데, 티켓 서버가 여러 대가 되면 데이터 동기화 문제가 발생한다.

<br>



## 트위터 스노플레이크 접근법

트위터가 사용하는 독창작인 ID 생성 기법이다. 

<br>

생성할 64비트 ID의 구조는 다음과 같다.

![ID 구조](https://github.com/fe-docker-study/cs-study-for-interview/blob/main/CS/%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/%ED%8F%AC%EB%8F%84/%EC%82%AC%EC%A7%84/ID%20%EA%B5%AC%EC%A1%B0.png)

- sign 비트 : 1비트를 할당한다. 음수와 양수 구분에 사용될 수 있다.
- 타임스템프 : 41비트를 할당한다. 기원 시각(epoch) 이후로 몇 밀리초가 경과되었는지 나타내는 값이다. 기원 시각의 경우 원하는 시각으로 설정 가능하다.
- 데이터 센터 ID : 5비트를 할당한다. 따라서 2^5(32)개의 데이터 센터를 지원할 수 있다.
- 서버 ID : 5비트를 할당한다. 따라서 데이터 센터 당 32개의 서버를 사용할 수 있다.
- 일련번호 : 12비트를 할당한다. 각 서버에서는 ID를 생성할 때마다 일련번호를 1씩 증가시키고, 1밀리초가 경과되면 0으로 초기화된다.

<br>



### 타임스탬프

시간의 흐름에 따라 큰 값을 가지기 때문에 ID를 시간 순으로 정렬 가능하게 된다. ID 구조를 따르는 값의 이진 표현 형태로부터 UTC 시각을 추출하려는 경우 다음 방법을 사용한다.

1. 십진수로 변환
2. 기원 시각을 더함
3. 결과로 얻어진 밀리초 값을 UTC 시각으로 변환

<br>



41비트로 표현할 수 있는 타임스탬프의 최댓값은 2^41-1로 대략 69년이다. 기원 시각을 현재에 가깝게 맞춰 놓으면 오버플로가 발생하는 시점을 늦출 수 있다. 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 이전하여야 한다.

<br>



### 일련번호

일련번호는 12비트이므로 2^12(4096)개의 값을 가질 수 있다. 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어낸 경우에만 0보다 큰 값을 가지게 된다.

<br>



## 추가 논의 사항

### 시계 동기화

현재 설계에서는 ID 생성 서버들이 전부 같은 시계를 사용한다고 가정하였으나, 하나의 서버가 여러 코어에서 실행되는 경우 유효하지 않은 가정일 수 있다. 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우에도 마찬가지이다.

NTP(Network Time Protocol)를 사용하면 해결할 수 있다.

** NTP : 인터넷에서 라우터 및 기타 하드웨어 디바이스의 클럭을 동기화하는 데 사용되는 프로토콜이다. 컴퓨터 클록 시간을 1/1000초 이하까지 동기화시키기 위해 UTC를 사용한다.

<br>



### 각 구조의 길이 최적화

애플리케이션의 특성에 따라 구조의 길이를 최적화할 수 있다. 예를 들어 동시성이 낮고 수명이 긴 애플리케이션의 경우 일련번호의 길이를 줄이고 타임스탬프의 길이를 늘리는 것이 효과적이다.

<br>



### 고가용성 

ID 생성기는 필수 불가결 컴포넌트이기 때문에 아주 높은 가용성을 제공해야 한다.
