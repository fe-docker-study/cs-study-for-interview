# 채팅 시스템 설계

## 설계 요구사항

- 1:1 채팅, 그룹 채팅을 모두 지원해야 한다.
- 모바일 앱과 웹 앱을 모두 지원해야 한다.
- 일별 능동 사용자 수 기준으로 5천만 명을 처리할 수 있어야 한다.
- 그룹 채팅의 경우 최대 100명까지 참가할 수 있어야 한다.
- 사용자 접속 상태 표시를 지원해야 한다.
- 텍스트 메시지만 주고받을 수 있다.
- 메시지 길이는 100000자 이하여야 한다.
- 채팅 이력은 영원히 보관되어야 한다.
- 다양한 단말을 지원하고 하나의 계정으로 여러 단말에 동시 접속을 지원해야 한다.
- 푸시 알림을 지원해야 한다.

<br>



## 개략적 설계안

채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애플리케이션이다. 클라이언트는 서로 직접 통신하지 않는다. 대신 각 클라이언트는 채팅 서비스와 통신한다. 채팅 서비스는 아래 기능을 제공해야 한다.

- 클라이언트들로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

<br>



채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속한다. 따라서 채팅 서비스의 경우 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제이다.

메시지 송신 클라이언트가 요청을 보내는 역할을 한다. 송신 클라이언트가 수신 클라이언트에게 전달할 메시지를 채팅 서비스에 보낼 때 HTTP 프로토콜을 사용한다. 클라이언트는 채팅 서비스에 HTTP 프로토콜로 연결한 다음 메시지를 보내 수신자에게 해당 메시지를 전달하라고 알린다. 

채팅 서비스와의 접속에는 keep-alive 헤더를 사용하면 효율적인데, 클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지할 수 있어서이다. TCP 접속 과정에서 발생하는 핸드셰이크 횟수도 줄일 수 있다. 

메시지 수신 시나리오는 조금 더 복잡하다. HTTP는 클라이언트가 연결을 만드는 프로토콜이며, 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데는 쉽게 쓰일 수 없다. 서버가 연결을 만드는 것처럼 동작할 수 있도록 다음과 같은 기술이 제안되었다.

<br>



### 폴링

폴링은 클라이언트가 주기적으로 서버에 새 메시지가 있냐고 묻는 방법이다. 폴링 비용은 폴링을 자주 하면 할수록 올라간다. 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다.

<br>



### 롱 폴링

폴링의 비효율적인 부분을 개선한 것이 롤 폴링이다. 롱 폴링의 경우 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다. 클라이언트는 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다. 

이 방법에는 다음과 같은 약점이 있다.

- 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있다. HTTP 서버들은 보통 무상태 서버이다. 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.
- 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다.
- 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속하여 비효울적이다.

<br>



### 웹소켓

서버가 클라이언트에 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다. 웹소켓 연결은 클라이언트가 시작한다. 한번 맺어진 연결은 항구적이며 양방향이다. 해당 연결은 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드된다. 이 연결이 만들어지고 나면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.

웹소켓은 HTTP 혹은 HTTPS 프로토콜이 사용하는 기본 포트 번호를 그대로 사용하기 때문에 방화벽이 있는 환경에서도 잘 동작한다.

웹소켓을 이용하면 메시지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로 단순하고 직관적이다. 유의할 점은 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 한다.

<br>



### 개략적 설계안

#### 무상태 서비스

이 설계안에서 무상태 서비스는 로그인, 회원가입, 사용자 프로파일 표시 등을 처리하는 전통적인 요청/응답 서비스이다. 무상태 서비스는 로드밸런서 뒤에 위치한다.

<br>



#### 상태 유지 서비스

이 설계안에서 유일하게 상태 유지가 필요한 서비스는 채팅 서비스이다. 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하기 때문이다. 클라이언트는 보통 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않는다.

<br>



#### 제3자 서비스 연동

채팅 앱에서 가장 중요한 제3자 서비스는 푸시 알림이다.

<br>



#### 규모 확장성

해당 규모의 트래픽을 서버 한 대로 처리하면 SPOF 문제를 야기할 수 있다.

<br>

![채팅 개략적 설계안](https://github.com/fe-docker-study/cs-study-for-interview/blob/main/CS/%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/%ED%8F%AC%EB%8F%84/%EC%82%AC%EC%A7%84/%EC%B1%84%ED%8C%85%20%EA%B0%9C%EB%9E%B5%EC%A0%81%20%EC%84%A4%EA%B3%84%EC%95%88.png)



- 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할을 담당한다.
- 접속상태 서버는 사용자의 접속 여부를 관리한다.
- API 서버는 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 점부를 처리한다.
- 알림 서버는 푸시 알림을 보낸다.
- 키-값 저장소에는 채팅 이력을 보관한다. 시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게 된다.













