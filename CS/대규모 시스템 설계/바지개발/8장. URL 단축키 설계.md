# 8장. URL 단축키 설계



## 1단계: 문제 이해 및 설계 범위 확정

- 모호함을 줄이고 요구사항을 알아내는 과정

1. URL 단축키 동작 예제 : https://www.systeminterview.com/q=chatsystem&c=loggedin&v=v3&l=long을 https://tinyurl.com/y7ke-ocwj로 줄이고 URL 리디렉션이 가능

2. 트래픽 규모 : 매일 1억개의 단축 URL 생성 → 높은 가용성과 규모 확장성, 장애 감내가 요구됨 → 초당 쓰기 연산 : 1억/24/3600=1160 → 읽기연산과 쓰기 연산 비율이 10:1이라 가정하면 읽기 연산은 초당 11,600회 발생(1160*10=11,600) → 10년 운영을 가정하면 1억*365*10 = 3650억개의 레코드 보관해야하고, 축약전 URL 평균길이가 100이라 가정하면 3650억*100바이트 = 36.5TB

3. 문자 제한 : 숫자(0-9)와 영문자(a-z,A-Z)만 사용

4. 단축 URL을 시스템에서 삭제하거나 갱신 여부 : 안됨

   

## 2단계: 개략적 설계안 제시 및 동의 구하기

### API 엔드 포인트

- 클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신

- REST스타일로 설계

- API단축키는 두 개의 엔드포인트를 필요로 함

  1. URL 단축용 엔드포인트 : 단축할 URL을 인자로 실어 POST 요청을 보냄 **POST/api/v1/data/shorten**

  - 인자: {longUrl:LongURLstring}
  - 반환: 단축 URL

  1. URL 리디렉션용 엔드포인트 : 단축 URL에 대해 HTTP요청이 오면 원래 URL로 보내주는 용도 **GET/api/v1/shortUrl**

  - 반환 : HTTP 리디렉션 목적지가 될 원래 URL

### URL 리디렉션

- 단축 URL을 받은 서버는 원래 URL로 바꿔 301 응답의 Location헤더에 반환

  ![클라이언트와 서버 사이의 통신 절차](https://user-images.githubusercontent.com/90545926/187007979-f10f689a-f9e3-4852-8c84-9d5181fc1271.png)

  클라이언트와 서버 사이의 통신 절차

- 301 Permanently Moved:

  - 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답
  - 영구적으로 이전되어 브라우저는 이 응답을 캐시함(재요청시 브라우저는 캐시된 URL 사용)

- 302 Found:

  - 주어진 URL로의 요청이 일시적으로 Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답

- 서버부하를 줄이는 방식이면 301 Permanently Moved, 트래픽 분석이 중요할 때는 Found를 사용하는게 유리

- 해시테이블에 <단축 URL, 원래 URL>의 쌍을 저장한다고 가정한 URL 리디렉션 구현

  - 원래 URL = hashTable.get(단축 URL)
  - 301 또는 302 응답 Location 헤더에 원래 URL을 넣은 후 전송

### URL 단축

- 긴 URL을 해시값으로 대응시킬 해시함수 fx는 URL이 다른 값이면 해시값도 달라져야하고, 계산된 해시값은 복원될 수 있어야함

  

## 3단계: 상세설계

### 데이터모델

- 메모리가 유한하고 비싸기 때문에 해시테이블을 실제적인 시스템에 적용하기 어려움
- 더 나은 방법은 <단축 URL, 원래 URL> 순서쌍을 관계형 데이터베이스에 저장하는 것 id(PK), shortURL, longURL

### 해시함수

- 해시함수는 원래 URL을 단축 URL로 변환하는데 사용

#### 해시값 길이0-9

- [0-9,a-z,A-Z]의 62개(10+26+26)의 문자로 구성
- 해시값의 길이를 정하기 위해서 3650억인 n의 최솟값을 찾아야 함
  - 62^6=568억, 62^7=3.5조 → 해시함수의 길이 7

#### 해시 후 충돌 해소

- CRC32, MD5, SHA-1과 같은 해시 함수 이용할 수 있는데 가장 짧은 해시값도 7보다 길기 때문에 처음 7개의 글자만 사용함 → 충돌 확률이 높아짐
- 충돌이 발생했을 때 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙임

```
longURL → 해시함수 → shortURL → DB 질의로 충돌 여부 확인 → 없으면 DB저장, 있으면 사전에 정한 문자열 추가
```

- DB 질의로 인한 오버헤드가 크기 떄문에 DB대신 블룸필터를 사용하면 성능을 높일 수 있음

<aside> 💡 **블룸필터** : 어떤 집합에 특정 원소가 있는지 검사할 수 있는도록 하는, 확률론에 기초한 공간 효율이 좋은 기술

![Untitled](https://user-images.githubusercontent.com/90545926/187007974-027ed485-819d-4fa0-a94b-7f53833d9e06.png)

- 블룸 필터는 m비트 크기의 비트 배열 구조
- 블룸 필터에서는 k가지의 서로 다른 해시함수를 사용하며, 각 해시 함수는 입력된 원소에 대해 m가지의 값을 균등한 확률로 출력
- 원소를 추가하는 경우, 추가하려는 원소에 대해 k가지의 해시 값을 계산한 다음, 각 해시 값에 대응하는 비트를 1로 설정
- 원소를 검사하는 경우, 해당 원소에 대해 k가지의 해시 값을 계산한 다음, 각 해시 값에 대응하는 비트값을 읽음. 모든 비트가 1인 경우 속한다고 판단하며, 나머지는 속하지 않는다고 판단
- 해시 함수는 기본적으로 충돌의 가능성이 있기에 블룸 필터에는 긍정 오류(false positive) 의 가능성이 있으나 반대로 부정 오류(false negative)의 가능성은 없음. 즉, 해당 값이 테이블 내 확률적으로 있거나 절대로 없음을 확인
- 블룸 필터의 원소 추가와 원소 검사에 걸리는 시간은 O(k)으로, 집합에 포함되어 있는 원소 수와 무관

</aside>

#### base-62 변환

- 진법변환(base conversion)은 URL 단축기를 구현할 때 흔히 사용되는 접근법
- 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야하는 경우에 유용
- 62진법을 쓰는 이유는 해시값에 사용할 수 있는 문자개수가 62개이기 때문
- 0은 1, 9는 , a는 11, Z는 61 → a:1010, Z:6110
- 10진수 1157 → 2*62^2 + 55*62^1+59 → 2, 55, 59 → 62진수 2TX

| 해시 후 충돌 해소                                            | base-62변환                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 단축 URL 길이 가변적                                         | ID값이 커지면 같이 길어짐                                    |
| 유일성이 보장되는 ID 생성기 필요 없음                        | 유일성이 보장되는 ID 생성기 필요                             |
| 충돌이 가능해서 해소 전략 필요                               | ID 유일성이 보장된 후 적용 가능 전략이기 때문에 충돌 불가능  |
| ID로부터 단축 URL을 계산하는 방식이 아닌 다음에 쓸 수 있는 URL을 알아내는 것이 불가능 | ID가 1씩 증가하는 값이라고 가정하면 다음에 쓸 수 있는 단축 URL이 무엇인지 쉽게 알아낼 수 있어서 보안상 문제가 될 수 있음 |

### URL 단축기 상세 설계

- 시스템 핵심 컴포넌트이기 때문에 처리흐름이 논리적으로 단순하고 기능적으로 항상 동작상태여야함

1. 긴 URL 입력 받음
2. 데이터베이스에 해당 URL 검사
3. 데이터베이스에 있다면 해당 단축 URL을 반환
4. 데이터베이스에 없으면 기본키로 쓸 ID 생성
5. 62진법 변환을 적용해 ID를 단축 URL로 만듦
6. ID, 단축 URL, 원래 URL로 새 레코드를 만든 뒤 단축 URL을 반환

| ID            | shortURL | longURL                                     |
| ------------- | -------- | ------------------------------------------- |
| 2009215674938 | zn9edcu  | http://en.wikipedia.org/wiki/Systems_design |

#### URL 리디렉션 상세 설계

![Untitled](https://user-images.githubusercontent.com/90545926/187007978-f9645679-d779-4fec-b8c0-ea053a077a61.png)

- 쓰기보다 읽기를 더 자주 하는 시스템이라 <단축 URL, 원래 URL>의 쌍을 캐시에 저장하여 성능을 향상

- 로드밸런서의 동작흐름

  1. 사용자가 단축 URL을 클릭

  2. 로드밸런서가 해당 클릭으로 발생한 요청을 웹서버에 전달

  3. 단축 URL이 캐시에 있는 경우 원래 URL을 바로 클라이언트에게 전달

  4. 캐시에 없으면 DB에서 꺼내 캐시에 넣은 후 클라이언트에게 반환

     

## 4단계: 마무리(추가 논의사항)

- 처리율 제한 장치(rate limiter): 엄청난 양의 URL 단축 요청에 무력화될 수 있는 보안 위험 방지
- 웹 서버의 규모확장: 무상태(stateless)계층으로 설계해 웹 서버를 자유로이 증설하거나 삭제 가능
- 데이터베이스 규모확장: 데이터베이스를 다중화하거나 샤딩하여 규모확장성을 달성할 수 있음
- 데이터 분석 솔루션: URL단축키에 데이터 분석 솔루션을 통합해 두면 중요한 정보(어떤 링크를 얼마나 많이 언제 클릭했는지)를 알 수 있음
- 가용성, 데이터 일관성, 안정성