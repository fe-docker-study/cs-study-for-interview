### 알림 시스템

- 최신 뉴스, 제품 업데이트, 이벤트, 선물 등 고객에게 중요할 만한 정보를 비동기적으로 제공

- 모바일 푸시 알림, SMS 메시지, 이메일 등 다양한 정보 전달 방식을 지원하는 알림 시스템

- 시스템 컴포넌트 사이의 결합도를 낮추기 위해 메시지 큐를 활용

  

## 1단계: 문제 이해 및 설계 범위 확정

- 알림의 종류 → 푸시 알림, SMS 메시지, 이메일
- 실시간(real-time) 여부 → 연성 실시간(soft real-time) 시스템 : 가능한 빨리 전달되지만 시스템 부하로 인한 약간의 지연 허용
- 지원 단말 → iOS, 안드로이드, 랩톱/데스크톱 지원
- 알림 생성자 → 클라이언트 애플리케이션 프로그램 or 서버 측 스케줄링
- 알림 허용 설정 → 사용자가 알림 차단(opt-out) 가능
- 하루 알림 건수 → 천만 건의 모바일 푸시 알림, 백만 건의 SMS 메시지, 5백만 건의 이메일



## 2단계: 개략적 설계안 제시 및 동의 구하기

### 알림 유형별 지원방안

**알림 제공자 → 제 3자 제공 서비스(푸시알림을 단말로 보냄) → 푸시 알림 수신단말**

- 알림 제공자(provider)

  - 알림 요청(notification request)을 만들어 애플 푸시 알림 서비스(APNS: Apple Push Notification Service)로 보내는 주체
  - 단말 토큰(device token) : 알림 요청을 보내는데 필요한 고유 식별자
  - 페이로드(payload): 알림 내용을 담은 JSON 딕셔너리

  ```json
  {
  	"aps":{
  					"alert":{
  						"title": "Game Request",
  						"body": "Bob wants to play chess",
  						"action-loc-key": "PLAY"
  					},
  					"badge":5
  				}
  }
  ```

- 제 3자 제공 서비스

  - iOS : 애플이 제공하는 원격 서비스인 APNS로 푸시알림을 iOS 장치로 보냄
  - 안드로이드: FCM(FIrebase Cloud Messageing)라는 전송 장치 사용
  - SMS 메시지: 트윌리오(Twilio), 넥스모(Nexmo)와 같은 제 3 사업자의 서비스를 사용
  - 이메일: 유명한 서비스로 센드그리드(Sendgrid), 메일침프(MailChimp) 등이 있음. 전송 성공률도 높고 데이터 분석 서비스도 제공



### 연락처 정보 수집 절차

- 앱을 설치하거나 게정을 등록할 때 API 서버는 해당 사용자의 정보를 수집해 데이터베이스에 저장



### 알림 전송 및 수신 절차

![Untitled](https://user-images.githubusercontent.com/90545926/190880926-182fe82f-7c47-4060-8ebb-a1352807be02.png)

- 개략적 설계안
  - 1부터 N까지의 서비스: 서비스 각각은 마이크로서비스(microservice)일수도 있고 크론잡(cronjob)일수도 있고, 분산 시스템 컴포넌트일 수도 있음
  - 알림 시스템: 알림 시스템은 알림 전송/수신 처리의 핵심. 1개 서버만 사용하는 시스템이라 가정하고 전송을 위한 API 제공과 제 3자 서비스에 전달할 알림 페이로드를 만들어야 함
  - 제 3자 서비스: 사용자에게 알림을 실제로 전달하는 역할. 확장성을 유의해하고 시장에 따라서 어떤 시스템은 사용할 수 없다는 걸 유의해야함(중국은 FCM 대신 제이푸시나 푸시와이 같은 서비스를 사용해야함)
  - iOS, 안드로이드, SMS, 이메일 단말 : 사용자는 자기 단말에서 알림을 수신
- 개략적 설계안의 문제점
  - SPOF(Single-Point-Of-Failure): 서버가 하나면 장애가 전체 서비스 장애로 이어짐
  - 규모확장성: 한 대 서비스로 푸시 알림에 관계된 모든 것을 처리해 DB나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없음
  - 성능 병목 : 사용자 트래픽이 많이 몰리는 시간에 시스템이 과부화 상태에 빠질 수 있음

![Untitled](https://user-images.githubusercontent.com/90545926/190880924-1ff45afe-bebe-402e-b786-6aaab5f7db40.png)

- 개선된 개략적 설계안

  - DB와 캐시를 알림 시스템의 주서버에서 분리
  - 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이뤄질 수 있도록 함
  - 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊음

  1. 1부터 N까지의 서비스 : 알림 시스템 서버의 API를 통해 알림을 보낼 서비스들
  2. 알림서버 기능
     - 알림 전송 API: 스팸방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용가능
     - 알림 검즘(validation): 이메일 주소, 전화번호 등에 대한 기본적 검증 수행
     - 데이터베이스 또는 캐시 질의: 알림에 포함시킬 데이터를 가져오는 기능
     - 알림 전송: 알림 데이터를 메시지 큐에 넣음(여러 개의 메시지 큐를 사용해 알림을 병렬적 처리 가능)
  3. 캐시: 사용자 정보, 단말 정보, 알림 템플릿 등을 캐시함
  4. 데이터베이스: 사용자, 알림, 설정 등 다양한 정보를 저장
  5. 메시지 큐: 시스템 컴포넌트 간 의존성을 제거하기 위해 사용. 다량의 알림이 전송돼야하는 경우를 대비한 버퍼 역할도 함
  6. 작업서버: 메시지 큐에서 전송할 알림을 꺼내서 제3자 서비스로 전달하는 역할
  7. 제 3자 서비스
  8. iOS, 안드로이드, SMS, 이메일 단말

- 전송 흐름

  1. API 호출해 알림 서버로 알림 전송

  2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져옴

  3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어 해당 이벤트를 위한 큐에 넣음

  4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼냄

  5. 작업 서버는 알림을 제3자 서비스로 보냄

  6. 제 2자 서비스는 사용자 단말로 알림을 전송

     

## 3단계: 상세설계

### 안정성

- 데이터 손실 방지

  - 알림 시스템은 알림 데이터를 데이터베이스에 보관하고 재시도 메커니즘을 구현해야함(알림 로그 데이터베이스를 유지하는 것은 한가지 방법)

- 알림 중복 전송 방지

  - 분산 시스템 특성상 같은 알림이 중복되어 전송되기도 하는데 빈도를 줄이기 위해서 중복을 탐지하는 메커니즘을 도입하고, 오류를 신중하게 처리해야 함(보내야 할 알림이 도착하면 그 이벤트 ID를 검사해 중복된 이벤트라면 버리고 그렇지 않으면 발송도 한가지 방법)

    

### 추가로 필요한 컴포넌트 및 고려사항

- 알림 템플릿

  - 알림 템플릿은 인자나 스타일, 추적 링크를 조정하기만 하면 사전에 지정한 형식에 맞춰 알림을 만들어 내는 틀
  - 알림 템플릿은 형식의 일관성을 유지할 수 있게 하고, 오류 가능성을 낮추고 알림 작성 시간을 줄임

- 알림 설정

  - 알림 설정 테이블에 사용자가 알림 설정을 상세히 조정할 수 있도록 함

  | user_id | bigInt  |                                               |
  | ------- | ------- | --------------------------------------------- |
  | channel | vachar  | 알림이 전송될 채널, 푸시 알림, 이메일, SMS 등 |
  | opt_in  | blooean | 해당 채널로 알림을 받을지 여부                |

- 전송률 제한

  - 한 사용자가 받을 수 있는 알림의 빈도를 제한해 너무 많은 알림을 보내지 않도록 함

- 재시도 방법

  - 알림 전송에 실패하면 해당 알림을 재시도 전용 큐에 넣고 같은 문제가 계속 발생하면 개발자에게 통지

- 푸시 알림과 보안

  - iOS와 안드로이드 앱의 경우 알림 전송 API는 appKey와 appSecret을 사용해 보안을 유지(인증된authenticated 혹은 승인된verified 클라이언트만 해당 API를 사용하여 알림)

- 큐 모니터링

  - 알림시스템을 모니터링할 때 중요한 메트릭 하나는 큐에 쌓인 알림의 개수 : 큐에 쌓인 알림의 개수가 크면 작업서버들이 이벤트를 빠르게 처리하고 있지 못함 → 작업서버 증설

- 이벤트 추적

  - 알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는데 중요.
  - 데이터 분석 서비스는 보통 이벤트 추적 기능도 제공해 보통 알림 시스템을 만들면 데이터 분석 서비스와도 통합함



### 수정된 설계안

![Untitled](https://user-images.githubusercontent.com/90545926/190880925-dfa95cae-7b2e-41d1-990d-9430f26efad9.png)

- 추가된 컴포넌트
  - 알림 서버에 인증과 전송률 제한 기능
  - 전송 실패에 대응하기 위한 재시도 기능 추가. 전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도
  - 전송 템플릿을 사용해 알림 생성 과정을 단순화하고 알림 내용의 일관성 유지
  - 모니터링과 추적 시스템을 추가해 시스템 상태를 확인하고 추후 시스템을 개선하기 쉽도록 함



## 4단계: 마무리(집중한 부분)

- 안정성 : 메시지 전송 실패율을 낮추기 위해 안정적인 재시도 메커니즘을 도입
- 보안: 인증된 클라이언트만이 알림을 보낼 수 있도록 appKey, appSecret 등 메커니즘 이용
- 이벤트 추적 및 모니터링: 알림이 만들어진 후 성공적으로 전송되기까지의 과정을 추적하고 시스템 상태를 모니터링하기 위해 알림 전송의 각 단계마다 이벤트를 추적하고 모니터링할 수 있는 시스템 통합
- 사용자 설정: 사용자가 알림 수신 설정을 조정할 수 있도록 해 알림을 보내기 전 반드시 해당 설정을 확인하도록 시스템 설계 변경
- 전송률 제한: 사용자에게 알림을 보내는 빈도를 제한