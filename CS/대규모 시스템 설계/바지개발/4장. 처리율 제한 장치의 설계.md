# 4장. 처리율 제한 장치의 설계

- 처리율 제한 장치(rate limiter) : 클라이언트 또는 서비스가 보내는 트래픽 처리율(rate)를 제어하기 위한 장치

  ex) HTTP 예시 : 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한. API 요청 횟수가 제한 장치에 정의된 임계치(threshold)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(block)됨

- 처리율 제한 장치 사례

  - 사용자는 초당 2회 이상 새 글을 올릴 수 없음
  - 같은 IP 주소로는 하루에 10개 이상 계정을 생성할 수 없음
  - 같은 디바이스로는 주당 5회 이상 리워드를 요청할 수 없음

- API에 처리율 제한 장치 이점

  - Dos(Denial of Service) 공격에 의한 자원 고갈(resource starvation)을 방지 : 추가 요청에 대해 처리를 중단함으로 Dos 공격 방지
  - 비용 절감 : 추가 요청 처리 제한으로 서버를 줄일 수 있고, 우선순위가 높은 API에 더 많은 자원 할당. 특히 제 3자 API에 사용료를 지불하는 회사에게 중요
  - 서버 과부하 방지 : 봇(bot)에서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러낼 수 있음

## 1단계 : 문제 이해 및 설계 범위 확정

- 처리율 제한 장치를 구현하는데 사용하는 알고리즘들은 고유한 장단점을 갖고 있음
- 면접관과 소통해 어떤 제한 장치를 구현해야하는지 분명히 해야함
- 질문 사례 :
  - 처리율 제한 장치의 종류 : 클라이언트 측 제한 장치인지 서버측 제한 장치인지 → 서버측 API를 위한 장치
  - API호출을 제어하는 기준 : IP주소, 사용자ID, … → 다양한 형태의 제어규칙(throttling role)을 정의할 수 있는 유연한 시스템
  - 시스템 규모 : 스타트업 정도 or 사용자가 많은 큰 기업 →  대규모 요청 처리 필요
  - 시스템 분산환경에서 동작 여부 → OK
  - 처리율 제한 장치 독립 여부 : 독립된 서비스 or 애플리케이션 코드 포함 → 알아서~
  - 요청이 제한된 경우 알려야하는가 → OK

### 요구사항

- 설정된 처리율을 초과하는 요청은 정확하게 제한
- 낮은 응답시간 : 처리율 제한 장치가 HTTP 응답시간에 나쁜 영향을 주면 안됨
- 가능한 적은 메모리
- 분산형 처리율 제한(distributed rate limiting) : 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야함
- 예외처리 : 요청이 제한되었을 때 사용자에게 분명히 보여줘야함
- 높은 결함 감내성(fault tolerance) : 제한 장치에 장애가 생겨도 전체 시스템에 영향을 줘서는 안됨

## 2단계 : 개략적 설계안 제시 및 동의 구하기

- 기본적인 클라이언트-서버 통신 모델을 사용하는 예제

### 처리율 제한 장치 위치

- 클라이언트에 위치하는 경우 : 클라이언트 요청은 쉽게 위변조가 가능해 안정적인 처리율 제한이 어렵고, 모든 클라이언트의 구현 통제가 어려움.

- 서버에 위치하는 경우 :

  ![Untitled](https://user-images.githubusercontent.com/90545926/180792007-838894e3-d552-4191-bf8c-52c9988e7873.png)

- 미들웨어를 만들어 놓는 경우 :

  ![Untitled](https://user-images.githubusercontent.com/90545926/180792011-9f82334c-9dd9-44cc-b7ed-bbf4f93ece03.png)

  - 클라우드 마이크로서비스의 경우 처리율 제한 장치는 보통 API 게이트웨이 컴포넌트에 구현.
  - 클라이우드 API 게이트웨이는 처리율 제한, SSL 종단(termination), 사용자 인증(authentication), IP허용 목록(whitelist) 관리 등을 지원하는 클라우드 업체가 유지보수를 담당하는 완전 위탁관리형 서비스.

### 위치 고려 시 확인할 점

- 프로그래밍 언어, 캐시 서비스 등 현재 사용하고 이는 기술 스택을 점검 : 사용하고 있는 프로그래밍 언어가 서버 측 구현을 지원하기 충분할 정도로 높은 효율 보장 여부
- 필요에 맞는 처리율 제한 알고리즘 탐색 : 서버 측에서 구현한다면 알고리즘을 자유롭게 선택가능하나 제3사업자의 게이트웨이를 이용한다면 선택지는 제한됨
- 설계가 마이크로서비스에 기반하고, 사용자 인증이나 IP 허용목록 관리 등을 처리하기 위한 API 게이트웨이가 포함됐다면 처리율 제한 기능 또한 게이트웨이에 포함시켜야 할 수 있음
- 처리율 제한 서비스를 구현하는데 충분한 인력이 없으면 상용 API 게이트웨이를 쓰는 것이 바람직

### 처리율 제한 알고리즘



#### 토큰 버킷(token bucket)

- 인터넷 기업들이 보편적으로 사용

- 아마존과 스트라이프가 API 요청을 통제(throttle)하기 위해 이 알고리즘을 사용

- 동작 원리

  - 토큰 버킷은 지정된 용량을 갖는 컨테이너고 사전에 설정된 양의 토큰이 주기적으로 채워짐
  - 토큰 공급기(refiller)는 버킷에 매초 2개의 토큰을 채움
  - 꽉 찬 버킷에는 토큰이 추가 되지 않고 버려짐(overflow)
  - 요청이 도착하면 버킷을 확인 후 하나의 토큰을 꺼내 요청을 시스템에 전달함. 토큰이 없으면 해당 요청은 버려짐

- 인자

  - 버킷크기 : 버킷에 담을 수 있는 최대 토큰 개수
  - 토큰 공급률 : 초당 공급하는 토큰 개수

- 통상적으로 API 엔드포인트마다 별도의 버킷을 둠

  ex) 사용자 기능이 포스팅, 친구추가, 좋아요가 있으면 사용자마다 3개의 버킷이 필요

- IP 주소별로 처리율 제한을 적용하면 IP주소마다 버킷을 할당

- 시스템 요청 처리율을 제한하고 싶다면 모든 요청이 하나의 버킷을 할당

- 장점

  - 쉬운 구현
  - 효율적인 메모리 사용
  - 짧은 시간에 집중되는 트래픽처리 가능

- 단점

  - 버킷 크기와 토큰 공급률을 적절하게 튜닝하는 게 까다로움

  ![Untitled](https://user-images.githubusercontent.com/90545926/180792023-13710381-ec08-42f8-bcdc-2b8f931c590d.png)

#### 누출 버킷(leaky bucket)

- 토큰 버킷 알고리즘과 비슷하나 요청 처리율이 고정

- 누출 버킷 알고리즘은 보통 FIFO 큐로 구현

- 동작원리

  - 요청이 들어오면 큐를 확인 후 빈자리가 있으면 큐에 추가 없으면 버림

  - 지정된 시간마다 큐에서 요청을 꺼내 처리

    ![Untitled](https://user-images.githubusercontent.com/90545926/180792026-725935a9-9ccc-4f89-b4cf-d9289ac5fb13.png)

- 인자

  - 버킷 크기 : 큐와 동일 사이즈. 큐에는 처리 항목을 보관
  - 처리율(outflow rate) : 지정된 시간당 치리할 항목의 개수를 지정

- 장점

  - 큐의 크기가 제한되어 효율적인 메모리 사용
  - 고정된 처리율이라 안정적 출력

- 단점

  - 단기간 많은 트래픽이 오면 오래된 요청들이 쌓이고 최신 요청이 버려짐
  - 인자를 올바르게 튜닝하기 어려움

- leaky bucket 샘플 소스

  ```java
  //Java Implementation of Leaky bucket
  
  import java.io.*;
  import java.util.*;
  
  class Leakybucket {
  	public static void main (String[] args) {
  		int no_of_queries,storage,output_pkt_size;
  		int input_pkt_size,bucket_size,size_left;
  		
  		//initial packets in the bucket
  		storage=0;
  		
  		//total no. of times bucket content is checked
  		no_of_queries=4;
  		
  		//total no. of packets that can
  		// be accommodated in the bucket
  		bucket_size=10;
  		
  		//no. of packets that enters the bucket at a time
  		input_pkt_size=4;
  		
  		//no. of packets that exits the bucket at a time
  		output_pkt_size=1;
  		for(int i=0;i<no_of_queries;i++)
  		{
  			size_left=bucket_size-storage; //space left
  			
  			if(input_pkt_size<=(size_left))		
  			{
  				storage+=input_pkt_size;
  				System.out.println("Buffer size= "+storage+
  					" out of bucket size= "+bucket_size);
  			}
  			else
  			{
  				System.out.println("Packet loss = "
  							+(input_pkt_size-(size_left)));
  							
  					//full size	
  				storage=bucket_size;
  				
  				System.out.println("Buffer size= "+storage+
  							" out of bucket size= "+bucket_size);
  				
  			}
  			storage-=output_pkt_size;
  		}
  	}
  }
  ```

<aside> 💡 토큰 버킷은 큰 버스트를 더 빠른 속도로 보낼 수 있고, 새는 버킷은 항상 일정한 속도로 패킷을 전송

</aside>

#### 고정 윈도 카운터(fixed window counter)

- 티임라인을 고정된 가격의 윈도로 나누고 각 윈도마다 카운터를 붙임
- 요청이 접수될 때마다 카운터 값이 1씩 증가
- 카운터 값이 설정된 임계치에 도달하면 새로운 요청은 새로운 윈도가 열릴 때까지 버려짐

![Untitled](https://user-images.githubusercontent.com/90545926/180791972-cd27eb82-12b2-4236-90bb-95ace6932e92.png)

![Untitled](https://user-images.githubusercontent.com/90545926/180791978-541d266a-5cd0-4fb3-9c15-558ae0ff88f1.png)

![Untitled](https://user-images.githubusercontent.com/90545926/180791981-f773cb9a-4839-462e-b0fc-0ee24d64ee96.png)

- 장점

  - 메모리 효율이 좋음
  - 이해하기 쉬움
  - 윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기 적합

- 단점

  - 윈도의 경계 부근에 순간적으로 많은 트래픽이 집중되는 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있는 문제

    ![Untitled](https://user-images.githubusercontent.com/90545926/180791983-05a268fc-e352-4e66-a550-bef07d858f7e.png)

#### 이동 윈도 로깅(sliding window logging)

- 고정 윈도 카운터 알고리즘의 문제점을 해결
- 요청의 타임 스탬프를 추적하고 보통 레디스의 정렬집합같은 캐시에 타임 스탬프 보관
- 새 요청이 들어오면 현재 윈도의 시작 시점보다 오래되어 만료된 스탬프를 제거하고 새 요청의 타임스탬프를 로그에 추가
- 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달하나 아닌 경우는 처리 거부

![Untitled](https://user-images.githubusercontent.com/90545926/180791985-35de941a-7f7c-4f0c-8ebe-aadc2be682cb.png)

- 장점
  - 허용되는 요청의 개수는 항상 시스템의 처리율 한도를 넘지 않음
- 단점
  - 거부된 요청의 타임스탬프도 보관하기 때문에 다량의 메모리를 사용

#### 이동 윈도 카운터(sliding window counter)

- 고정 윈도 카운터 + 이동 윈도 로깅

![Untitled](https://user-images.githubusercontent.com/90545926/180791987-d18e5911-3171-4b9a-aedd-081e42350189.png)

- 계산법

  - 처리율 제한 장치 한도가 분당 7개

  - 이전 1분동안 5개, 현재 1분동안 3개의 요청이 들어옴

  - 현재 위도에 몇개의 요청이 온건지 계산 = 계산 현재 1분간의 요청 수 + 직전 1분간의 요청수 * 이동 윈도와 직전 1분이 겹치는 비율

    3+5* 70% = 6.5개

- 장점

  - 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응
  - 메모리 효율이 좋음

- 단점

  - 직전 시간의 처리율로 계산하기 때문에 다소 느슨(클라우드플레어의 실험에 따르면 40억개의 요청 가운데 맞지 않게 허용되거나 버려진 요청이 0.003%에 불가)

### 개략적인 아키텍처

- 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 두고(사용자별로 추적할 것인가? 아니면 IP주소별로? 아니면 API 엔드포인트나 서비스 단위로?), 이 카운터의 값이 어떤 한도를 넘어서면 넘어선 요청은 거부하는 것이 처리율 제한 알고리즘의 기본 아이디어

- 카운터의 보관은 빠르고 시간에 기반한 만료정책을 지원하는 메모상에 동작하는 캐시를 사용하는 게 바람직

  ex) 레디스는 처리율 제한 장치를 구현할 때 자주 사용하는 메모리 기반 저장장치로  INCR, EXPIRE 명령어 지원(INCR-메모리에 저장된 카운터 값을 1 증가, EXPIRE-카운터에 타임아웃값을 설정)

### 동작원리

- 클라이언트가 처리율 제한 미들웨어에게 요청
- 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와서 한도에 도달했는지 검사
- 한도에 도달했으면 거부, 도달하지 않았으면 요청은 API 서버로 전달
- 미들웨어는 카운터의 값을 증가시킨 후 다시 레디스에 저장

# 3단계 : 상세설계

## 처리율 제한 규칙

- 리프트(Lyft)는 처리율 제한에 오픈 소스를 사용

```jsx
// 마케팅 메시지의 최대치를 하루에 5개로 제한
domain : messaging
descriptors :
	- key : message_type
	  value : marketing
	  rate_limit :
	  	unit : day
	  	requests_per_unit: 5
//클라이언트가 분당 5회 이상 로그인 할 수 없도록 제한
domain : auth
descriptors :
	- key : auth_type
	  value : login
	  rate_limit :
	  	unit : minute
	  	requests_per_unit: 5
```

## 처리율 한도 초과 트래픽의 처리

- 어떤 요청이 한도 제한에 걸리면 API는 HTTP 429 응답(too many requests)을 클라이언트에게 보냄
- 경우에 따라서는 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 보관하기도 함

### 처리율 제한 장치가 사용하는  HTTP 헤더

- 클라이언트는 HTTP 응답 헤더(response header)로 요청 처리에 대한 정보를 알 수 있음
  - X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능 요청의 수
  - X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
  - X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림
- 사용자가 너무 많은 요청을 보내면  HTTP 429 응답(too many requests)을 X-Ratelimit-Retry-After 헤더와 함께 반환

## 상세 설계

![Untitled](https://user-images.githubusercontent.com/90545926/180791991-6b2c31f0-1e4e-4403-955c-76da4b7fb0d3.png)

- 처리율 제한 규칙은 디스크에 보관
- 작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장
- 클라이언트가 요청을 서버에 보내면 요청은 먼저 처리율 제한 미들웨어에 도달
- 처리율 제한 미들웨어는 제한 규칙을 캐시에서 가져오고 카운터 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져와 가져온 값들에 근거하여 해당 미들웨어가 결정
  - 해당 요청이 처리율 제한에 걸리지 않은 경우에는 API 서버로 보냄
  - 해당 요청이 처리율 제한에 걸렸다면 429 too many requests 에러를 클라이언트에 보냄(해당 요청은 그대로 버릴 수도 있고 메시지 큐에 보관할 수 있음)

## 분산 환경에서의 처리율 제한 장치의 구현

- 단일 서버를 지원하는 처리율 제한 장치를 구현하는 건 어렵지 않으나 여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것은 또 다른 문제

### 경쟁 조건

- 처리율 제한 장치의 동작은 레디스에서 카운터의 값을 읽음(counter) → counter +1의 값이 임계치를 넘는지 확인 → 넘지 않는다면 레디스에 보관된 카운터 값을 1만큼 증가

- 요청 처리 스레드가 병렬로 처리할 때 경쟁조건 이슈가 발생 할 수 있음

  ![Untitled](https://user-images.githubusercontent.com/90545926/180791995-828161dc-02d4-442d-a712-9ca0d05f4ea6.png)

- 경쟁 조건 문제를 해결하는 널리 알려진 해결책은 락(lock)이나 시스템 성능을 저하시킴

- 위 설계의 경우 락 대신 루아 스크립트(Lua Script)와 레디스의 자료구조인 정렬 집합(sorted set)을 쓸 수 있음

<aside> 💡 Redis 는 기본적으로 Single Threaded Redis 의 경우 자료구조가 Atomic 하기 때문에, 해당 Race Condition을 피할 수 있음

</aside>

### 동기화 이슈

- 여러 대의 처리율 제한 장치 서버를 두면 동기화가 필요

- 웹 계층은 무상태이므로 클라이언트의 이전 처리상태를 알지 못한 상태로 다른 제한 장치로 보내게 되면 처리율 제한이 제대로 수행되지 못함

  ![Untitled](https://user-images.githubusercontent.com/90545926/180792000-7cf73b31-75b9-41e4-bc5e-415d7b314279.png)

- 고정 세션 : 클라이언트로부터 요청은 항상 같은 처리율 제한 장치로 보냄. 규모의 확장이 불가능하고 유연하지 않음

- 레디스와 같은 중앙 집중형 데이터 저장소 사용

  ![Untitled](https://user-images.githubusercontent.com/90545926/180792003-e8a58cea-3bae-4ebb-a46e-19e2a3187413.png)

### 성능 최적화

- 데이터센터에 멀리 떨어진 사용자를 지원하려면 지연시간(latency)가 증가하기 때문에 여러 데이터센터를 지원하는 문제는 처리율 제한 장치에 매우 중요한 문제
- 대부분의 클라우드 서비스 사업자는 세계 곳곳에 에지 서버(edge server)를 심어놓음
- 제한 장치 간에 데이터를 동기화할 때 최종 일관성 모델을 사용

### 모니터링

- 기본적으로 처리율 제한 장치의 동작 모니터링을 통해 확인하려는 것은 두 가지
  - 채택된 처리율 제한 알고리즘이 효과적 : 트래픽 패턴을 잘 처리할 수 있는지 확인
  - 정희한 처리율 제한 규칙이 효과적 : 제한 규칙이 빡빡하면 더 많은 유효 요청이 처리 되지 못함

# 4단계 : 마무리

- 경성(hard) 또는 연성(soft) 처리율 제한
  - 경성 처리율 제한 : 요청의 개수는 임계치를 절대 넘어설 수 없음
  - 연성 처리율 제한 : 요청 개수는 잠시 동안만 임계치를 넘어설 수 있음
- 다양한 계층에서의 처리율 제한
  - 지금까지 애플리케이션 계층(OSI 7계층)에서의 처리율 제한에 대해서만 살펴보았지만 다른 계층에서도 처리율 제한이 가능
    - 예를 들어, Iptables를 사용하면 IP 주소(OSI 3계층)에 처리율 제한을 적용하는 것이 가능
- 클라이언트 설계로 처리율 제한을 회피하는 방법
  - 클라이언트 측 캐시를 사용하여 API 호출 횟수를 줄임
  - 처리율 제한의 임계치를 이해하고, 짧은 시간 동안 너무 많은 메시지를 보내지 않도록 함
  - 예외나 에러를 처리하는 코드를 도입하여 클라이언트가 예외적 상황으로부터 우아하게(gracefully) 복구될 수 있도록 함
  - 재시도 로직을 구현할 때는 충분한 백오프(back-off) 시간을 둠