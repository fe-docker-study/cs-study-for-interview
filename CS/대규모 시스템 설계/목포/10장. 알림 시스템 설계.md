# 10장. 알림 시스템 설계


## 조건 설정
* push 알림, SMS 메세지, 이메일 알림을 지원해야 함
* 연성 실시간(soft real-time) 이라고 가정한다. (시스템 부하가 높을 때는 약간 지연되어도 괜찮음.)
* ios, aos, laptop, desktop을 지원해야 함.
* 알림 생성 작업은 클라이언트 app에서하거나 서버 쪽에서 스케줄링해둔다.
* 사용자가 알림을 받지 않도록 설정할 수 있어야 한다.
* 하루에 천 만건의 모바일 푸시 알림, 백만 건의 SMS 메세지, 5백만 건의 이메일을 보낼 수 있어야 함.


## 개략적 설계안
먼저 개략적인 설계안을 세워보자. 일단 각 알림 종류의 동작 원리를 알아야 한다.

### 1. 알림 유형별 지원 방안
**ios 푸시 알림**
- 알림 제공자(provider == thrid party) : 알림 요청(notification request)를 만들어 애플 푸시(APNS)로 보내는 주체다. 알림 요청에는 다음과 같은 데이터가 필요하다.
    - 단말 토큰(device token) : 요청에 필요한 고유 식별자
    - 페이로드(payload) : 알림 내용을 담은 json 데이터

```json
// payload example
{
    "aps" : {
        "alert" : {
            "title" : "Game Request",
            "body" : "Bob wants to play chess",
            "action-loc-key" : "PLAY"
        },
        "badge" : 5
    }
}
``` 
- APNS : 애플이 제공하는 **알림 서비스 플랫폼**이다. 푸시 알림을 ios로 보내는 역할을 한다.
- ios 단말 : 푸시 알림을 수신하는 단말

**aos 푸시 알림**
- ios와 비슷하며, APNS 대신 FCM을 사용한다.

**SMS 메시지**
- SMS 메세지를 보낼 때는 보통 트윌리오, 넥스모 같은 third-party 사업자의 서비스를 쓴다. (사용서비스로 비용 발생)

**이메일**
- 마찬가지로 센드그리드, 메일침프 같은 third-party 사업자의 서비스가 애용된다. 만들 수도 있지만, 전송 성공률, 데이터 분석 서비스도 잘 제공되기 때문이다.

### 2. 연락처 정보 수집 절차
알림을 보낸다는 건 받는 사람의 정보가 필요하다는 것과 같다. (모바일 단말의 토큰, 전화번호, 이메일 주소 등이 필요할 것이다.) 보통 사용자가 우리 앱을 설치하거나 최초로 계정을 등록하면 API 서버가 해당 사용자의 정보를 수집하는 식으로 처리한다. 

필수 데이터만 담는다고하면 아래와 같이 설계할 수 있다. 한 사용자가 여러 단말을 가질 수 있고, 모든 단말에 전송할 수 있다는 가정 하에 설계되었다.
[그림]


### 3. 알림 전송 및 수신 절차
먼저 플로우를 생각해보자.

1. 1부터 N까지의 서비스가 있다고 생각해보자. 이 서비스들은 msa일 수도 있고, 크론 잡일 수도 있고, 분산 시스템 컴포넌트일 수도 있다. 
2. 알림 시스템 : 알림 전송/수신 처리의 핵심적인 부분이다. 서비스 1~N에 알림 전송을 위한 API를 제공해야하며, third-party 서비스에 전달할 알림 payload도 만들어 낼 수 있어야 한다.
3. third-party services : 사용자들에게 알림을 전달하는 역할을 한다. 
    - third-party 서비스를 이요할 때는 확장성을 고려해야한다. 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다는 말인데, 중국같은 곳에서는 FCM을 쓸 수 없기 때문이다. 

#### 문제점
위 플로우에는 문제가 몇 가지 있다. 
1. SPOF(Single-Point-Of-Failure) : 역시나 분산처리가 되어있지 않아, 장애 처리에 취약하다.
2. 규모 확장성 : 한 대의 서버로 알림 기능을 처리하고 있어 db, 캐시 등의 컴포넌트를 개별적으로 증가시키기 어렵다.
3. 성능 병목 : 알림 서비스는 자원을 많이 필요로 하기 때문에 역시 서버 한 대로는 처리하기 어렵다.

## 개선된 설계안✅
앞에서 짚어본 문제점을 다음과 같이 개선해보자.
1. db와 cache를 알림 시스템의 주 서버에서 분리
2. 알림 서버 증설
3. 메세지 큐로 시스템 컴포넌트 사이의 강한 결합을 끊기

[그림]

### 알림 서버 
알림 서버는 다음과 같은 기능을 제공하면 된다. 
- 알림 전송 API : 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능하다.
- 알림 검증 : 이메일 주소, 전화번호에 대한 기본적 검증 수행
- db or cache 질의 : 알림에 포함시킬 데이터를 가져오는 기능
- 알림 전송 : 알림 데이터를 메세지 큐에 넣는다. 하나 이상의 메세지큐를 사용하면 병렬적으로 알림 전송을 처리할 수 있음.
    - ```curl
        POST https://api.example.com/v/sms/send
        {
            "to": [
                {
                    "user_id" : 123456
                }
            ],
            "from" : {
                "email" : "from_address@example.com"
            },
            "subject" : "Hello, world!",
            "content" : [
                {
                    "type" : "text/plain",
                    "value" : "Hello, world!"
                }
            ]
        }
        ```

### 캐시 
사용자 정보, 단말 정보, 알림 템플릿 등을 캐시

### DB
사용자, 알림, 설정 등의 정보를 저장

### Message Queue
시스템 컴포넌트 간 의존성 제거를 위해 사용. 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할도 함. 
위 그림대로라면 third-party service 중 하나에 에러가 발생해도 다른 종류의 알림들은 동작할 것이다.

### 작업 서버
message queue 에서 전송할 알림을 가져가 제 3자 서비스로 전달한다.

### 동작 순서
1. API를 호출하여 알림 서버로 알림을 보낸다.
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 metadata를 cache나 db에서 가져온다. 
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어 해당 이벤트를 위한 큐에 넣는다.
4. 작업 서버는 메세지 큐에서 알림 이벤트를 꺼낸다.
5. 작업 서버는 알림을 third-party service로 보낸다.
6. third-party service는 사용자 단말로 알림을 전송한다.


## 상세 설계
위의 개략적 설계에 대한 내용을 좀 더 자세히 알아보자.

### 안정성
**1. 데이터 손실 방지**  
알림 전송 시스템의 가장 중요한 요구사항은 무엇일까? 알림이 지연되는 건 괜찮지만, 알림이 소실되면 안 된다. 데이터 소실 방지를 위해서는 db에 해당 알림을 보관(notification log)하고 재시도 메커니즘을 구현할 필요가 있다.

[그림]

**2. 알림 중복 전송 방지**  
[분산 시스템의 경우 같은 알림의 반복을 완전히 막을 수는 없다.]("https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/") 하지만, 그 빈도를 줄이려면 중복을 탐지하는 메커니즘을 도입하는 편이 좋을 것이다. 예를들면, 보내야 할 알림이 도착하면 **그 이벤트 ID를 검사하여 이전에 본 적이 있는 이벤트인지 살핀다.**


### 추가 컴포넌트 및 고려사항

**1. 알림 템플릿**  
대형 알림 시스템은 하루에 수백만 건 이상의 알림을 처리하는데 대부분 비슷한 형식을 가진다. 이런 유사성을 고려해 인자(parameter)나 스타일, 추적 링크 등을 정의해두면 형식의 일관성을 유지할 수 있고, 오류 가능성 감소, 알림 작성 비용 등에서 이득을 볼 수 있다.

```
// example

본문 : 
[item_name]이 입고 되었습니다. [date]까지 주문할 수 있습니다.
타이틀 : 
[user_name]님 지금 바로 확인하세요.
```


**2. 알림 설정**  
사용자는 알림 수신 여부를 스스로 정할 수 있어야 한다. 이 여부 정보는 알림 설정 테이블에 보관한다.

```
user_id     bigInt
channel     varchar        # 알림이 전송될 채널, 푸시 알림, 이메일, SMS 등
opt_in      boolean        # 해당 채널로 알림을 받을 것인지 여부
```


**3. 전송률 제한**  
한 사용자가 받을 수 있는 알림의 빈도를 제한해두면 한 사용자에게 너무 많은 알림이 가는 것을 막을 수 있다.

**4. 재시도 방법**  
third-party service가 알림 전송에 실패하면, 재시도 전용 큐에 넣는다. 같은 문제가 발생하면 개발자에게 alert할 수 있게 한다.

**5. 푸시 알림과 보안**  
ios와 aos 경우, 알림 전송 API는 appKey와 appSecret을 사용하여 보안을 유지한다. 따라서 authenticated 또는 vertifed된 클라이언트만 해당 API를 사용하여 알림을 보낼 수 있다. 

**6. 큐 모니터링**  
알림 시스템을 모니터링할 때 중요한 메트릭은 **큐에 쌓인 알림의 개수**이다. 이 수가 너무 크면 작업 서버들이 이벤트를 빠르게 처리하지 못하고 있다는 뜻이다. 그 때는 작업서버를 증설하는 것이 좋다.

**7. 이벤트 추적**  
알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는데 중요하다. 데이터 분석 서비스와 함께 연동하면 좋다.  
[그림]

### > 개선 후
[그림]


