

# 객체 지향 프로그래밍  

***객체지향은 낮은 관계의 의존성과 높은 기능의 집중도를 지향하여, 소프트웨어의 유연함을 극대화 하는 개발 기법***



### 유연한 소프트웨어 특징

- 코드 중복이 거의 없다.

- 코드 속성과 메소드의 캡슐화가 잘 되어 있다.

- 코드 배치의 일관성이 잘 지켜졌다.

- 코드 가독성이 좋다.

- 코드 의존성이 낮다.

- 사이드 이펙트의 감소

- 코드 재사용이 쉽다.

- 코드 수정, 추가, 디버그가 수월하다.

- 유지보수와 고도화 프로젝트하기 좋다.



|      | 절차적 프로그래밍                                            | 객체지향 프로그래밍                                          |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 장점 | \- 객체나 클래스를 만들 필요없이 바로 프로그램을 코딩 <br />- 필요한 기능을 함수로 만들어 두기 때문에 같은 코드를 복사하지 않고 호출해 사용 <br />- 프로그램의 흐름을 쉽게 추적 | \- 모듈화, 캡슐화로 인해 유지보수 용이 <br />- 객체지향적이 때문에 현실세계와 유사해 코드를 이해하기 쉬움 <br />- 객체는 그 자체가 하나의 프로그램이기 때문에 다른 프로그램에서 재사용 가능 <br />- 클래스 단위로 모듈화 시켜서 개발할 수 있으므로 업무분담이 쉬움 |
| 단점 | \- 각 코드가 유기성이 높아 수정하기 힘듦 <br />- 코드를 재사용할 수 없어 비용과 시간이 늘어날 수 있음 <br />- 오류 검사가 어려움 | \- 속도가 상대적으로 느려지고, 많은 메모리를 사용하는 경향 <br />- 설계과정에 시간이 많이 투자 |



### 객체자향의 기본요소 5가지

#### 객체

최소한의 데이터(속성)와 이 데이터를 다루는 기능(메소드)를 모두 갖춘, 독립적으로 실행할 수 있는 최소한의 단위

객체가 생성되었다는 것은 데이터와 기능을 담은 클래스가 메모리에 로드되어 소프트웨어 세계에서 실체로 존재한다는 뜻

#### 클래스 

유사한 특징을 가진 대상들을 일정하게 묶어서(추상화) 하나의 종류로 정의한 분류와 범주. 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 설계도

#### 속성

객체가 가지고 있는 고유의 값, 또는 변수

#### 메소드

객체가 자신 또는 다른 객체에게 제공하는 기능을 적절한 문장으로 정의하고 그 기능을 코드로 구현한 결과물

객체의 속성을 변경하는 유일한 통로가 되어야함 

#### 생성자

객체가 최초에 생성될 때 호출되는 일종의 메소드로 객체가 처음 생성되는 순간에 객체가 어떤 특별한 일을 해야한다면 생성자에서 구현



### 객체지향의 근본조건

낮은 결합도, 높은 응집도를 지키기 위한 필수조건

#### 상속

부모클래스의 속성과 메소드를 자식클래스가 물려받아 사용함으로 소스가 중복되지 않고 코드 사용이 편리

코드를 상속관계로 묶어 클래스 간의 체계화된 전체 구조를 파악할 수 있음

클래스 그룹의 코드를 변경할 때 부모 클래스의 코드를 수정하면 되기 때문에 코드의 수정과 확장이 편리하고, 자식 클래스는 부모클래스의 기능을 자신의 특성에 맞게 재정의할 수 있음

#### 캡슐화

관련있는 여러 정보들을 틀안에 담아 외부에 필요없는 정보들을 노출시키지 않고 숨김

다른 객체가 속성에 직접 접근할 수 없어 객체 안의 데이터가 보호됨

#### 다형성

같은 그룹에 속하는 클래스들의 동일한 메소드를 호출할 때 자식 클래스들이 저마다 다른 로직을 수행하고 리턴하는 것. 

다형성을 사용함으로 관계의 의존성이 낮아지고, 클라이언트 클래스의 코드 변경없이 기능의 수정과 확장이 무제한으로 가능

##### 다형성을 위한 3가지 원칙

1. '기능을 제공할' 비슷한 종류의 클래스들을 모아 클래스 그룹으로 조직화

2. 기능을 제공할 클래스 크룹의 인터페이스를 통일

3. 클라이언트 클래스에서는 쓰고 싶은 클래스 그룹의 부모 클래스만 의존하고 자식 클래스를 인자로 넘겨받아 저장한다. 

   

### 객체지향 구현원리 5가지

#### SRP(Single Responsibility Principle)

시스템의 모든 객체는 하나의 책임을 수행하는데 집중해야하고, 각 클래스의 수정 이유도 오직 하나라면 단일 책임의 원리를 정확히 구현한 것

#### OCP(Open Closed Principle)

기존에 개발된 클래스에 수정사항이 발생하면 기존 클래스를 수정하지 않고, 새로운 클래스나 기능을 만들어 확장해야함(기능 확장에는 열려있고, 코드 수정에는 닫혀있음)

상속, 오버라이드, 다형성이 OCP를 지원

#### LSP(Liskov Substitution)

자식 클래스는 부모 클래스가 사용되는 곳에 대체될 수 있어야 함.

자식타입들은 부모타입들이 사용되는 곳에 100% 대체할 수 있으면 상속을 하나, 규칙을 만족시키지 못한다면 상속보다 더 강력한 단순 위임이나 위임을 사용

#### ISP(Interface Segregation)

인터페이스 관점에서 '클래사ㅡ는 자신이 사용하지 않는 메소드에 의존하면 안된다'라는 인터페이스 사용 가이드라인

자식 클래스는  쓰지 않는 인터페이스를 억지로 상속받게 되면 상위 부모 인터페이스를 분리해야 함

#### DRY(Don't Repeat Yourself) / DIP(Dependency Inversion Principle)

##### DRY

공통되는 부분을 추출하여 추상화하고 한곳에 두어 중복코드를 피함

어떤 코드나 기능이 소프트웨어 내에서 분명하고 유일한 주체성을 가진다면, 같은 내용의 코드가 다른 장소(클래스)에 존재하면 안됨

##### DIP

구체적인 클래스 대신 추상적인 클래스에 의존(클라이언트 클래스에서는 부모 클래스만 의존하고 자식 클래스를 인자로 넘겨받아 저장)



참고 : 

\- 김동헌, **『**객체지향 프로그래밍**』**, 비즈북스(2019)
