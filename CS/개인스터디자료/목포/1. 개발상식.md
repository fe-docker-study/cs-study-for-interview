# OOP

[객체]("")의 관점에서 프로그래밍하고자 하는 것.

## 객체 지향의 특성

### 캡슐화

### 추상화

### 다형성

### 상속성, 재사용

## 객체 지향적 설계 원칙(SOLID)

### 1. Single Responsibility Principle : 단일 책임 원칙

말 그대로 각 클래스는 하나의 목적을 가지고 그 책임을 다 해야하며, 클래스 변경 시 그 이유는 한 가지여야만 한다.

객체에 관계없는 작업과 너무 많은 것을 담으려고 하는 것은 안된다. 그렇지 않으면 클래스를 유지하기가 어려워지기 때문이다.

다음은 텍스트를 조작할 수 있는 기능을 담은 클래스이다. 언뜻보면 괜찮아 보이지만 이 클래스는 두 개의 책임을 지고 있다. 텍스트를 조작하는 기능과 텍스트를 출력하는 기능.

```Java
public class TextMnipulator {
     private String text;

    public TextManipulator(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }

    public void appendText(String newText) {
        text = text.concat(newText);
    }

    public String findWordAndReplace(String word, String replacementWord) {
        if (text.contains(word)) {
            text = text.replace(word, replacementWord);
        }
        return text;
    }

    public String findWordAndDelete(String word) {
        if (text.contains(word)) {
            text = text.replace(word, "");
        }
        return text;
    }

    public void printText() {
        System.out.println(textManipulator.getText());
    }
}
```

SRP 원칙에 따라 이를 수정하려면 하나의 다른 클래스를 만들어 텍스트 출력을 다뤄야한다. 이제 이 클래스에는 출력과 관련된 모든 작업들을 추가하거나 수정할 수 있게된다.

```Java
public class TextPrinter {
    TextManipulator textManipulator;

    public TextPrinter(TextManipulator textManipulator) {
        this.textManipulator = textManipulator;
    }

    public void printText() {
        System.out.println(textManipulator.getText());
    }

    public void printOutEachWordOfText() {
        System.out.println(Arrays.toString(textManipulator.getText().split(" ")));
    }

    public void printRangeOfCharacters(int startingIndex, int endIndex) {
        System.out.println(textManipulator.getText().substring(startingIndex, endIndex));
    }
}
```

### 2. Open/Closed Principle : 개방-폐쇄 원칙

클래스들은 확장을 위해서는 열려있어야하고 수정을 위해서는 닫혀있어야한다.

```Java
public class Guitar {
    private String make;
    private String model;
    private int volume;

    //Constructors, getters&setters
}
```

우리가 기타에 대한 클래스를 이렇게 만들고 서비스 런칭을 했다고 해보자. 몇 달 뒤 우리가 만든 기타에 질려 좀 더 멋진 기타를 만들고 싶어졌다. 어떤 사람은 Guitar 클래스의 코드를 수정하여 몇몇 기능을 추가하려 할 수도 있지만 open-closed 원칙에 의거해 이를 확장하면 다음과 같이 만들 수 있다.

```Java
public class SuperCoolGuitarWithFlames extends Guitar {
    private String flameColor;
}
```

### 3. Liskov Substitution : 리스코프 치환 원칙

상위 타입의 객체를 하위타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다.

```Java
public interface Car {
    void turnOnEngine();
    void accerlerate();
}
```

--- 작성 중
