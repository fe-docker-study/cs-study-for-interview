로드밸런서 개념

# 4계층 장비

- TCP와 같은 4계층 헤더에 있는 정보를 이해하고 이 정보들을 기반으로 동작한다.
- 4계층 장비는 기존 2, 3계층 장비에서 고려하지 않았던 통신의 방향성이나 순서와 같은 통신 전반에 대한 관리가 필요하며,
- 이런 정보를 세션 테이블(Session Table)이라는 공간에 담아 관리한다.

# 로드밸런서란?

<img width="506" alt="image" src="https://user-images.githubusercontent.com/47748246/147861082-31aeac99-5428-48c2-8f43-e9fa89a95ca3.png">


- 트래픽을 분배해주는 기능을 함.
- 스케일 아웃 : 사용자 천 명의 요청을 동시에 처리해주는 서버보다 사용자 5천 명의 요청을 동시에 처리해주는 서버의 가격은 5배가 아니라 이보다 훨씬 비쌈.
- 이처럼 내부 부품을 이중화 하거나 더 큰 부품을 사용하면 가격이 크게 올라가므로, **작은 장비 여러 대를 묶어 사용하는 방법**을 선호한다. ⇒ **스케일 아웃**
- 이때, 작은 시스템을 여러 대 운영하더라도, 사용자 입장에서는 하나의 서비스로 보여야함. 따라서 로드 밸런서가 서비스에 사용되는 대표 IP 주소를 서비스 IP로 갖고 그 밑에 시스템이 늘어나면 로드밸런서가 각 시스템의 실제 IP로 변경해 요청을 보낸다.

### L4 스위치 (L4 로드 밸런싱)

<img width="666" alt="image" src="https://user-images.githubusercontent.com/47748246/147861085-d8469393-2c02-46b0-8042-44d513c97db6.png">


- TCP, UDP 정보(특히 포트 넘버)를 기반으로 로드밸런싱을 수행
- L4 스위치가 동작하기 위해서는 가상 서버(Virtual Server), 가상 IP(Virtual IP), 리얼 서버(Real Server), 리얼 IP (Real IP)를 설정해야 한다.
- 여기서 L4 스위치는 가상 IP를 리얼 IP로 변경해주는 역할을 한다 .
- TCP 레벨의 간단한 Dos 공격을 방어하거나 서버 부하를 줄이기 위해 TCP 세션 재사용과 같이 보안과 성능을 높여주는 기능도 함께 제공할 수 있다.
    
    <img width="680" alt="image" src="https://user-images.githubusercontent.com/47748246/147861091-9166bbed-6c6b-4abd-8b62-a9355303979a.png">
    

### ADC (L7 로드 밸런싱)

- HTTP, FTP, SMTP와 같은 애플리케이션 프로토콜 정보를 기반으로 로드밸런싱을 수행한다.
- 즉, HTTP 헤더 정보나 URI와 같은 저보를 기반으로 프로토콜을 이해한 후 부하를 분산할 수 있다.
- 프록시(Proxy) 역할을 수행한다.
- 애플리케이션 프로토콜을 이해하고 애플리케이션 **내용**에 대한 분산, 리다이렉션, 최적화를 제공해 L4 스위치보다 더 다양한 기능을 사용할 수 있다.
- ADC는 **성능 최적화**를 위해 서버에서 수행하는 작업 중 부하가 많이 걸리는 작업을 별도로 수행한다. 그 중 하나가 이미지나 정적 컨텐츠 **캐싱(Caching)** 기능이다.
  <img width="680" alt="image" src="https://user-images.githubusercontent.com/47748246/147861094-0852dba9-2133-4865-97e8-0899b6c72818.png">
  
    
- 웹 서버에는 콘텐츠 압축 기능이 있지만 ADC에서 이 역할을 수행해 웹 서버의 부하를 줄일 수 있다. ADC는 하드웨어 가속이나 소프트웨어 최적화를 통해 이런 부하가 걸리는 작업을 최적화하는 기능이 있다 .
  <img width="660" alt="image" src="https://user-images.githubusercontent.com/47748246/147861101-d26b9413-b774-4101-aad5-f11bdebb033a.png">
  
    
- 최근 SSL 프로토콜을 사용하는 비중이 늘면서 웹 서버에 SSL 암복호화 부하가 늘고 있다. ADC에서는 SSL의 엔드 포인트로 동작해 클라이언트에서 ADC까지의 구간을 SSL로 처리해주고 ADC와 웹 서버 사이를 일반 HTTP를 이용해 통신한다.
   <img width="660" alt="image" src="https://user-images.githubusercontent.com/47748246/147861107-5dd01bb2-fada-4e65-a33b-cf8c7e360832.png">

    

# 로드밸런서 기능

<aside>
📖 로드 밸런서의 구성과 동작 모드를 이해해야만 서비스에 필요한 구성을 할 수 있다.

</aside>

## 부하분산

1. **부하분산이란?**
    - 단일 서버로 구성할 때의 문제점 : 해당 서버의 애플리케이션, 운영체제, 하드웨어에 장애가 발생했을 때, 정상적인 서비스를 제공할 수 없음
    - 따라서 서비스의 가용성을 높이기 위해 하나의 서비스는 보통 두 대 이상의 서버로 구성한다.
    - 로드 밸런서에는 동일한 서비스를 하는 다수의 서버가 등록되고 사용자로부터 서비스 요청이 오면 로드 밸런서가 대표로 받아 다수의 서버에 서비스 요청을 분산시켜 부하를 분산한다.
    - 로드 밸런서는 서비스를 위한 가상 IP(VIP)를 제공하고 사용자는 각 서버의 개별 IP 주소가 아닌 가상 IP를 통해 각 서버로 접근한다.
    
    <img width="660" alt="image" src="https://user-images.githubusercontent.com/47748246/147861114-38e9e7c9-c331-4125-9aae-a24cab0c38b3.png">
    
2. **부하 분산 방법**
    
    
3. **부하 분산 알고리즘**
    
    1) 라운드 로빈
    
    - 순차적으로 돌아가면서 트래픽 분산
    - 모든 장비의 총 누적 세션 수는 같아진다.
    
    2) 최소 접속 방식
    
    - 서버가 가진 세션 부하를 확인해 그것에 맞게 부하를 분산
    - 로드밸런서의 세션 테이블을 통해 각 장비에 연결된 현재 세션 수를 알 수 있다.
    - 이를 통해 현재 세션이 가장 적게 연결된 장비로 서비스 요청을 보내는 방식
    
    3) 해시 
    
    - 서버의 부하를 고려하지 않고 클라이언트가 같은 서버에 지속적으로 접속하도록 하기 위해 사용하는 부하 분산 방식
    - 서버 상태를 고려하는 것이 아니라 해시 알고리즘을 이용해 얻은 결괏값으로 어떤 장비로 부하를 분산할지를 결정한다.
    - 해시 알고리즘에 사용하는 값은 주로 출발지 IP 주소, 목적지 IP 주소, 출발지 서비스 포트, 목적지 서비스 포트이다.
    

## 로드밸런서 구성 방식

<img width="709" alt="image" src="https://user-images.githubusercontent.com/47748246/147861116-e93b0b70-8092-4122-a7b2-57ccfb68f516.png">

### **1) 원암(One-Arm) 구성**

- 서버로 가는 트래픽 중 부하 분산을 수행하는 트래픽에 대해서만 로드밸런서를 경유한다.
- 로드밸런서 부하 감소
    - 불필요한 트래픽이 로드밸런서에 유입되지 않아 로드밸런서 부하를 줄일 수 있다.
- 대역폭 확장성
    - 스위치와 로드밸런서 간의 대역폭을 최소화할 수 있고,
    - 대역폭이 부족할 때는 이 구간만 대역폭을 증설하면 되므로, 인라인 방식보다 확장에 유리하다.
- 장애 영향도 감소
    - 로드밸런서 장비에 장애가 발생하더라도 로드 밸런서를 거치지 않는 서비스의 트래픽 흐름에는 문제가 없음

### **2) 인라인(Inline) 구성**

- 부하 분산을 포함한 모든 트래픽이 로드 밸런서를 경유하는 구성
- 트래픽이 흐르는 경로에 로드 밸런서가 있어서 서버로 향하는 트래픽이 로드 밸런서의 서비스를 받는지 여부와 상관 없이 로드밸런서를 모두 통과한다.
- 로드밸런서의 부하가 높아진다.

## **로드 밸런서 동작 모드**

- 로드 밸런서 동작 모드에 따라 패킷 통신 방식도 달라지므로 로드 밸런서 동작 모드의 이해는 로드 밸런서의 운용 및 장애조치를 위해서도 매우 중요하다.

### 1) Transparent Mode

<img width="707" alt="image" src="https://user-images.githubusercontent.com/47748246/147861119-eb3c2d69-a1bb-4a8a-87c2-5f73d3836885.png">


- 로드밸런서가 OSI 2계층 스위치처럼 동작하는 구성
- 부하 분산 서비스를 받는 트래픽인 경우에만 4계층 이상의 기능을 수행하며
    
    부하 분산 서비스가 아닌 경우에는 기존 L2 스위치와 동일한 스위칭 기능만 수행
    

[트래픽 흐름]

- 요청
    
    <img width="707" alt="image" src="https://user-images.githubusercontent.com/47748246/147861124-d83c9395-b80a-4efb-a04d-1512fd71f459.png">
    
    - 사용자 → 로드밸런서의 VIP 주소 10.10으로 서비스 요청
    - 로드밸런서로 들어온 패킷은 **목적지 IP 주소**를 VIP에 바인딩되어 있는 **실제 서버 IP 주소로 변경(Rewrite)**하므로 목적지 IP 주소는 10.10에서 10.11로 변경된다 .
    - 목적지 MAC 주소도 **실제 서버의 MAC 주소인 C**가 된다.
    - 이때, 로드밸런서와 목적지 서버가 **동일한 네트워크 대역**이므로 L3 장비를 지날 때처럼 **출발지 MAC 주소는 변경되지 않는다.**
- 응답
    - 로드밸런서를 지나면서 **출발지의 IP 주소**가 **실제 서버의 IP에서 VIP 주소로 변경**되지만, 목적지 MAC 주소는 변경되지 않는다. (서버에서 응답할 때, 목적지 MAC 주소가 이미 게이트웨이의 MAC 주소를 갖고 있어 변경할 필요가 없기 때문)

### 2) Routed Mode

<img width="707" alt="image" src="https://user-images.githubusercontent.com/47748246/147861129-c914a238-bc49-418b-abbb-f5c3725db6fc.png">

- 로드밸런서가 라우팅 역할을 수행
- 즉, 로드 밸런서를 기준으로 Client Side와 Server Side가 서로 다른 네트워크로 분리됨.
- Routed Mode는 보안 강화 목적으로 서버 쪽 네트워크를 사설로 구성해 서버에 직접 접속하는 것을 막는 용도로 사용되기도 한다.

[트래픽 흐름]

- 요청
    
    <img width="707" alt="image" src="https://user-images.githubusercontent.com/47748246/147861133-87250e53-3ed1-4290-bac5-bd86b9ea7012.png">
    
    - 사용자 : 서비스 IP인 VIP 주소 10.10으로 서비스를 요청함.
    - 로드밸런서로 들어온 **패킷의 목적지 IP 주소**는 VIP에 바인딩된 **실제 서버 IP 주소**인 20.11로 **변경**된다.
    - 일반 라우팅과 동일하게 **출발지와 목적지의 MAC 주소도 각각 A→D, B→C로 변경**된다.
    - 목적지 IP와 출발지/목적지 MAC이 변경된 패킷은 라우팅 테이블을 확인해 실제 서버로 전송된다 . 이 과정에서 로드 밸런서는 서비스를 위한 VIP에서 실제 서버의 IP 주소로 변경해 전송하므로 Destination NAT가 되었다고 한다.
- 응답
    
    <img width="707" alt="image" src="https://user-images.githubusercontent.com/47748246/147861135-238d0796-47a0-4ff1-b47d-3ae3dbf7696e.png">
    
    - 서버
        - 출발지 IP : 실제 서버의 IP 주소, 목적지 IP : 원래 사용자의 IP 주소
        - **목적지 MAC** : 목적지 IP가 외부 네트워크이므로, 외부로 나가는 관문인 로드 밸런서의 MAC 주소가 된다.
    - 로드밸런서
        - 로드 밸런서로 들어온 패킷은
        - 출발지 IP : 실제 서버의 IP인 20.11에서 사용자가 서비스를 위해 요청했던 VIP인 10.10으로 변환됨.
        - 출발지와 목적지의 MAC 주소를 변경한 후 사용자에게 응답 패킷을 전송한다.

### 3) DSR (Direct Server Return) Mode

- 명칭 그대로 사용자의 요청이 로드밸런서를 통해 서버로 유입된 후에 다시 로드밸런서를 통하지 않고 서버가 사용자에게 직접 응답하는 모드
- 즉, 로드밸런서는 사용자가 요청하는 패킷에 대해서만 관여한다.
- DSR 모드는 응답할 때, 로드 밸런서를 경유하지 않으므로 원암으로 구성한다.

# **로드 밸런서 유의사항**

## 문제 1: 원암 구성의 동일 네트워크 사용 시

- 원암 구성에서 서비스 네트워크(로드밸런서)와 서버 네트워크가 동일한 네트워크로 구성된 상황에서 발생할 수 있는 문제
    
    <img width="707" alt="image" src="https://user-images.githubusercontent.com/47748246/147861141-673c43aa-3ec2-489a-aa5b-faccb6c8c701.png">

    
    
    [원암 구성 설명]
    
    - 사용자가 서비스 IP (로드밸런서의 IP)로 요청하면, 로드 밸런서는 실제 서버의 IP 주소로 Destination NAT한 후 서버로 전달한다.
    - 서버는 응답할 때, 게이트웨이 장비인 L3 스위치를 통해 응답하는데 원암 구성에서는 로드 밸런서를 거치지 않고 사용자에게 바로 응답한다.
    
    [문제점]
    
    - 따라서 **사용자는 VIP로 요청했지만, 응답은 실제 서버의 IP로 받게 됨.** 서비스를 호출한 사용자 입장에서는 **요청하지 않은 IP에서 응답 패킷을 받았으므로** 해당 패킷은 정상적으로 처리지되지 않고 **폐기**된다.
    - 이 문제는 로드밸런서를 거치면서 변경된 IP가 재응답할 때, 로드밸런서를 다시 경유하면서 원래의 IP로 바꾸어 응답해야 하지만 원암 구조에서는 **응답 트래픽이 로드 밸런서를 경유하지 않아서 발생**한다.
    
    ### **해결방법**
    
    1. **게이트웨이를 로드 밸런서로 지정**
        - 서버에서 동일 네트워크가 아닌 목적지로 가려면 게이트웨이를 통과해야 한다.
        - 따라서 로드 밸런서를 통해 부하 분산이 이루어지는 실제 서버에 대해서는 **게이트웨이를 로드 밸런서로 설정**하면 로컬 네트워크가 아닌 외부 사용자의 호출에 대한 응답이 항상 로드 밸런서를 통하므로 정상적으로 사용자에게 응답할 수 있게 된다.
        
        **(단점)** 
        
        - 다만 이 경우, 물리적으로는 원암 구조이지만 실제 트래픽 플로우가 로드 밸런서를 게이트웨이로 사용하므로 원암 구조에서 가질 수 있는 로드 밸런서의 부하 감소효과가 줄어든다.
        - 물론 **부하 분산을 사용하지 않는 서버**는 기존과 동일하게 게이트웨이 주소를 L3 스위치로 설정하면 로드밸런서를 경유하지 않으므로 여전히 로드 밸런서의 부하 감소효과를 가져올 수 있다.
        
    2. **Source NAT 사용**
        - Destitnation NAT 뿐만 아니라 출발지 IP 주소를 로드 밸런서가 가진 IP로 함께 변경한다.
        - 그럼 서버에서는 사용자의 요청이 아니라 로드 밸런서가 요청을 한것으로 보이기 때문에 응답을 로드 밸런서로 보내게됨
        - 로드 밸런서는 패킷의 출발지르 실제 서버에서 로드 밸런서에 있는 VIP로 바꾸고 목적지 IP 주소를 로드 밸런서의 IP에서 원래의 사용자 IP로 변경해 사용자에게 응답한다.
        - 이 경우 서비스를 호출할 때 응답할 때 모두 Source/Destination NAT을 수행하게 된다.
        
        **(단점)**
        
        - 다만 이 경우, 서버 애플리케이션 입장에서 보면 서비스를 호출한 IP가 하나의 동일한 IP로 보이기 때문에 사용자 구분이 어렵다는 문제가 있다.
        - 웹 서비스는 이런 문제를 **해결**하기 위해 HTTP 헤더의 X-Forwared-For (XFF)를 사용해 실제 사용자 IP를 확인하는 방법을 사용하기도 한다.
    

## 문제2) 동일 네트워크 내에서 서비스 IP (VIP) 호출

<img width="707" alt="image" src="https://user-images.githubusercontent.com/47748246/147861145-27e5fb15-b7ac-4b5e-8db8-b1eea33f9189.png">

[문제점]

서버 1은 로드 밸런서의 서비스 IP를 통해 부하 분산이 이루어지고 있는 서버

1. 서버2에서 서버1의 서비스 IP 호출을 위해 로드 밸런서로 서비스 요청
2. 로드 밸런서에서는 목적지 IP인 서비스 IP 주소를 서버1의 IP 주소로 변환해 서버 1로 전달한다. 
3. 서비스 요청을 받은 서버1은 서비스를 호출한 출발지 IP를 확인해 응답하는데 이때 서비스를 호출한 출발지가 자신과 동일한 네트워크임을 확인한다. 동일한 네트워크이므로 목적지에 대해 로드 밸런서를 거치지 않고 바로 응답한다. 
4. 서버2에서는 서비스를 요청한 IP 주소가 아닌 다른 IP 주소로 응답이 오므로 해당 패킷은 폐기되면서 정상적인 서비스가 이루어지지 않게 된다.

[해결방법]

- 서비스 요청이 로드 밸런서를 거칠 때, 출발지 IP 주소를 로드밸런서의 IP로 변경하는 Source NAT 방법 사용
