# 멀티캐스팅 및 멀티캐스트 라우팅 프로토콜

## 네트워크 통신방법

### 유니캐스트

- 단 한곳으로 데이터를 전송하는 것은 유니캐스트
- TCP/IP 통신의 대부분은 유니캐스트

### 브로드캐스트

- 같은 네트워크 상의 모든 호스트에 완전히 똑같은 데이터를 전송하는 것
- 브로드캐스트 IP주소는 32비트가 모두 1인 주소 : 255.255.255.255

### 멀티캐스트

- 같은 애플리케이션이 동작하는 등 특정 그룹에 포함되는 호스트에 완전히 똑같은 데이터를 전송하는 것

- 멀티캐스트 IP 주소는 224.0.0.0~239.255.255.255로 범위가 정해져 있고 이 범위 중 미리 정해져 있는 멀티 캐스트가 있음( 224.0.0.2는 같은 네트워크 상의 모든 라우터라는 그룹, 사용자가 자유롭게 그룹을 결정하기 위해서 239로 시작되는 범위를 사용할 수 있음

  

## 멀티캐스트 라우팅

- 그룹끼리 통신하는 방식
- 그룹별로 송신 호스트와 그룹 멤버를 연결시켜주는 트리가 구성되며 라우팅 테이블과 달리 별도의 포워딩 테이블이 필요
- 멀티캐스트 전송 IP 주소는 특정그룹주소를 사용하고, 패킷을 받은 수신자는 자신이 패킷의 그룹에 속해있는지 판단하여 패킷의 수용여부를 결정

### DVMRP(Distance Vector Multicasting Routing Protocol)

- 유니캐스트 라우팅에서 사용하는 거리벡터 알고리즘 RIP의 확장

- 동작 절차

  1. 첫 데이터그램은 전체 네트워크로 플러딩
  2. 이 트래픽을 받은 종단 라우터들은 종단 서브네트워크에 연결되어 있는 그룹 멤버가 없으면, Prune 메시지를 송신지를 향해 역방향으로 전송
  3. Prune 메시지를 통하여 그룹 멤버로 이어져 있지 않은 모든 가지들 을 제거
  4. 소스 기반의 최단 경로 (shortest-path) 트리 구성 (주기적 동작)

  ![Untitled](https://t1.daumcdn.net/cfile/tistory/227BDA3857288EA907)

### MOSPF(Multicast Open Shortest Path First)

- OSPF의 멀티캐스트 확장
- DVMRP와 달리 트리를 최단 경로 대신에 최소 비용 트리를 사용
- 각 라우터는 자신이 루트(root)가 되고 다른 나머지 라우터들이 트리의 노드가 되는 최소 비용 트리를 생성하기 위해서 다익스트라 알고리즘을 사용

![Computer Networks 2 Lecture 1 Multicast. - ppt video online download](https://slideplayer.com/slide/6393877/22/images/13/MOSPF%3A+Example+Source+1+Z+W+Q+T+Receiver+1+Receiver+2.jpg)

### PIM(Protocol Independent Multicast)

- DVMRP 및 MOSPF의 장점과 CBT알고리즘을 각각 결합

- 기존의 DVMRP 와 MOSPF와 같은 멀티캐스트 라우팅 구조는 멀티캐스트 스룹이 지역내에 모여있고, 지역 내 대역폭이 충분하다는 전제하에 사용되고 구현된 것이므로, 그룹 내 멤버가 지역적으로 드물게 분산되어 있을 경우, 이러한 라우팅 구조는 효율적이지 못함. 즉, DVMRP 의 경우에는 데이터 패킷이 상대적으로 전송하지 말아야 할 링크 까지도 데이터를 전송하는 경우가 발생하며, MOSPF의 경우는 멤버쉽을 결정하는 정보들이 직접적인 송수신자들이 없는 링크에 까지도 데이터가 전송될 경우가 발생

- PIM은 CBT처럼 PIM내에 "Rendezvous Point"라고 불리는 각각의 그룹을 하나 이상의 Core 라우터를 이용함으로서 그룹상에 오버헤드를 감소시킨다. 또한, PIM은 유니캐스트와는 독립적이며, Shortest Path Tree 와 Optional Core Based Tree를 유지하며 일부 또는 경우라도 효율적인 라우팅을 할 수 있도록 지원

- PIM은 그룹의 멤버가 밀집되어 있는 환경을 위한 프로토콜(PIM-DM)과 다양한 지역에 널리 분포되어 있는 환경을 위한 프로토콜(PIM-SM)로 구분

  

## 라우팅 프로토콜

### 라우팅 프로토콜

- 라우팅 테이블을 동적으로 갱신하는 동적 라우팅에서 사용하는 프로토콜을 라우팅 프로토콜이라고 함

- 라우팅 프로토콜의 동작

  1. 라우터끼리 경로 정보를 교환
  2. 수집한 경로에서 최적 경로를 골라냄

- 서브넷 마스크 정보에 대한 지원 여부에 따라 Classful, Classless로 나눠지고, 알고리즘에 의해 Distance Vector방식과 Link State 방식으로 분류

  

### 정적 라우팅과 동적 라우팅

#### 정적 라우팅 Static Routing

- 네트워크 접속이 변경될 때마다 관련된 라우터 등의 라우팅 테이블을 수동으로 수정하고, 이외는 고정된 라우팅 테이블을 사용
- 불필요한 라우팅 정보 없이 라우팅 테이블을 간소하게 구성하여 라우터의 부하를 최소화할 수 있음
- 네트워크 규모가 아주 작고, 구성변경이 거의 없는 경우 간단히 사용
- 네트워크의 접속 라우터에 관한 정보를 라우터끼리 정기적 또는 필요에 따라 서로 교환하여 그 정보를 기반으로 라우팅 테이블을 자동 관리
- 내부의 라우팅 토폴로지가 외부에 알려지지 않기 원하는 상황에서도 사용

#### 동적 라우팅 Dynamic Routing

- 라우터들끼리 라우팅 테이블에 의해 서로 정보를 교환하고 학습하는 방법

- 관리의 부하가 적고, 경로 문제가 생기면 바로 대처가 가능

### Classful vs Classless

#### Classful Routing

- 목적지의 네트워트 ID를 IP주소의 Class로 결정
- 라우팅 정보를 교환할 때 목적지 네트워크 ID에 대한 서브넷 마스크를 전송하지 않아 라우터의 부하와 라우팅 프로토콜에 의해 발생하는 트래픽이 적음
- CIDR, VLSM과 같이 서브넷 마스크 정보가 반드시 필요한 네트워크 ID를 지원하지 못함

#### Classless Routing

- 서브넷 마스크에 대한 정보를 전송함으로 Classful Routing 보다 유연하고, 광범위하게 확장할 수 있음

- ip를 효율적으로 사용하기 위해 ip주소를 클래스에서 더 쪼개어 사용하고, 클래스의 개념이 사라진 ip주소들을 구분하기 위해 Subnet mask를 사용하여 Routing 하는 방식

### 동적 라우팅이 라우팅 정보를 학습하는 방법(알고리즘)

- 디스턴스 벡터 알고리즘 Distance Vector Routing Algorithm
  - 인접한 라우터끼리 라우팅 정보를 학습
  - 디스턴스 벡터 알고리즘의 대표적인 프로토콜 RIP
- 링크 스테이트 알고리즘Link Stat Routing Algorithm
- 패스 벡터 알고리즘 Path Vector Algorithm
  - 대규모 네트워크 통신 캐리어 사업자용 네트워크 내에서 사용되고 있는 BGP4가 유명

#### Distance(Bellman-Ford) Vector

1. 초기 설정을 끝낸 각 라우터들은 일정한 간격으로 자신이 가지고 있는 라우팅 정보 전체를 네트워크에 브로드캐스트로 알림

2. 메시지를 수신한 라우터는 거리를 계산해 더 빠른 경로면 자신의 라우팅 테이블에 기록

   ![Routing Basics : Distance Vector vs Link State Routing Protocol - Route XP  Private Network Services](https://1.bp.blogspot.com/-svJELb9XBmo/WSLxmgyyVEI/AAAAAAAAAZg/qWYpuSrnIEgwLRGDTyfv9mZhJY18j7X9gCLcB/s1600/Screen%2BShot%2B2017-05-22%2Bat%2B7.41.07%2BPM.png)

- 정기적인 업데이트 기능
- 브로드캐스트 업데이트
- 각 라우터들이 전송하는 메시지에는 목적지 네트워크(Vector)와 그 거리(Distance)에 대한 정보가 담김
- 구현하기가 쉽고, 라우팅 테이블의 Distance 연산이 복작하지 않아 이 프로토콜을 사용하는 라우터에 부하가 적음
- 라우팅 정보가 변경되었을 경우 전체 라우터가 인지하는 데 걸리는 시간이 신속하지 못함
- 네트워크 규모가 커질수록 라우팅 프로토콜이 만드는 트래픽이 많아지고, Routing Loop의 위험성과 확장성이 떨어짐

#### Link State(Shortest path First) Routing

1. 라우터는 자신이 네트워크에 연결되어 초기화 되는 과정에서 인접 Link, 인접 라우터의 상황을 Hello 패킷을 사용하여 파악(Hello 메시지를 전송하여 응답이 오면 그쪽 연결은 UP상태, 아닌 경우 Down 상태로 판단하여 자신의 Link State에 대한 구성도를 그림. 연결상태를 파악하기 위한 Hello 메시지는 정기적으로 자신과 연결된 Link로 전송되며, 그 안에는 라우터의 ID와 패킷을 전송한 인터페이스의 IP, 서브넷 마스크 등에 대한 정보가 저장)

2. Link State를 파악한 각 라우터들은 LSA 패킷을 만들어 네트워크에 멀티캐스트로 전송(변경이 생긴 경우)

3. (인접 라우터로부터 알게된 라우팅 정보에 자신을 추가하여 전송하는 Distance Vector 방식과는 다르게) Link State는 인접 라우터로부터 받은 LSA 메시지를 복사한 후 다음 라우터에게 Flooding 함

4. 라우터는 자신에게 수신된 LSA를 퍼즐조작처럼 연결하여 영역 전체의 지도인 Link state Database(네트워크 토폴로지와 각 연결의 cost에 대한 정보)를 구성

   ![img](https://mblogthumb-phinf.pstatic.net/20130106_43/bansanghyeon_1357480706816MI4B7_PNG/1.PNG?type=w800)

- 네트워크에 참여한 라우터들이 자신이 속한 영역의 네트워크 토폴로지에 대한 정보를 보유하기 때문에 최상의 경로를 신속하게 결정
- 알고리즘을 통해 최적의 경로를 계산하기 때문에 라우터에 부하를 많이 주기 때문에 소규모 영역에 대한 설계와 구성이 선차적으로 이뤄져야함(OSPF의 경우 한 Area내에 라우터 20대 정도로 구성하는 것을 권장)
- LSA를 Flooding하는 특성때문에 Link State 방식은 네트워트가 확장되더라도 라우팅 정보를 담은 메시지가 눈덩이 불듯이 불어나지 않음

### IGP vs EGP

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/15e4f2c9-adbf-4f28-b9f4-98f42f163af7/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211218%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211218T094118Z&X-Amz-Expires=86400&X-Amz-Signature=4e99ca591a9b719fb7eb6d0999dd5d5f92ed89e0b7128642bec2028778839a07&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- IGP(Interior Gateway Protocol) : 주로 AS(한개의 ISP 또는 한 대기업이 담당하는 대규모 네트워크를 자율시스템 Automomous System이라함)내의 라우팅에 이용
  - RIP/RIP2(Routing Information Protocol) :
    - 소규모 네트워크에 이용되며 구입이나 운영이 간단
    - 변경을 반영하는 데 시간이 걸리며 경로를 선택할 때 통신 속도 등이 고려되지 않는 단점
    - 벨만 포드 알고리즘을 사용한 hop 수 기반 라우팅 프로토콜로 최대 16홉을 지원, 소규모망에 적합
    - 30초마다 라우팅 테이블을 이웃라우터들과 공유
  - OSPF(Open Shortest Path First)
    - 중규모 이상의 네트워크에 사용
    - 구입이나 운영에 걸리는 공수가 늘어가는 경향이 있으며, 저렴한 기기로는 대응할 수 없는 경우가 있음
    - 다익스트라 알고리즘기반 방식으로 최적 경로 선택을 위해 홉수, 대역폭, 지연시간 등을 고려
- EGP(Exterior Gateway Protocol) : 주로 AS 간의 라우팅에 이용
  - BGP(Border Gateway Protocol) 
    - 규모가 큰 망을 지원할 수 있는 Path Vector기반 라우팅 프로토콜
    - 도중에 통과하는 AS의 일람을 비롯한 몇 가지 정보를 기반으로 해서 어떤 네트워크를 따라 다다르기 까지 최적 경로를 선택





# 전송계층

- 트랜스포트 계층이 제공하는 서비스를 통해 원거리의 호스트에서 동작하는 각종 응용프로그램과 안정적인 통신을 보장받을 수 있고, 하위 네트워크 계층의 토폴로지와 프로토콜에 독립적인 네트워트 응용프로그램을 개발할 수 있음

  | 데이터 링크 계층                                             | 전송계층                                                     |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 물리적으로 1:1 연결된 호스트 사이의 전송. 직접 묶여 있는 호스트-노드 또는 노드-노드 사이에서 오류제어, 흐름제어 | 논리적으로 1:1 연결된 송신과 수신 호스트 사이의 전송. End to End(종단간)호스트로, 양끝에 있는 호스트 사이에서 오류제어, 흐름제어 |

- 응용프로그램 서비스에 대한 위치 정보 제공 송신 호스트의 응용프로그램이 통신하기 원하는 응용프로그램이 구동되는 호스트의 위치정보가 IP 주소라면 트랜스포트 계층의 주소는 그 호스트에서 응용프로그램의 위치정보를 제공

- 응용프로그램에 대한 위치는 트랜스포트계층이 제공하는 서비스 Access포인트(Transport Service Access Point:TSAP)인 Port로 표시

#### 수신 호스트

1. 특정한 요청을 담은 데이터를 수신하여 처리한 후 응답을 하는 프로세스들은 트랜스포트 서비스에게 특정 포트로 요청이 오면 자신에게 연결시킬 것을 명령(Listen, Passive Open)
2. 명령을 받은 트랜스포트 서비스는 이 내용을 특정한 데이터 블록(Transport Control Block: TCB)에 저장을 하고 해당 포트에 대한 연결 요청이 들어오면 이를 수용하여 연결을 성립

#### 송신 호스트

1. 특정 서버 프로세스에 데이터를 요청하고자 하는 송신 호스트의 프로세스(클라이언트 프로세스)는 요청을 트랜스포트 서비스에 명령(Connect, Active Open)
2. 명령을 받은 트랜스포트 서비스는 상태편 호스트의 트랜스포트 서비스에 특정 포트로의 연결을 요청하고, 수신 쪽이 허락하면 연결이 성립



## UDP

- UDP는 트랜스포트 서비스 간의 연결을 통한 메시지 혹은 데이터의 전송을 하지 않고 단순히 두 호스트의 응용프로그램 계층의 프로세스에 대한 위치 정보만을 제공
- 실시간 멀티미디어 전송과 같이 데이터의 전송 신뢰도보다는 빠른 속도를 보장해야하는 통신에 사용
- 멀티캐스팅이나 브로드캐스트와 같이 일 대 다수의 통신을 가능하게 함
- 정기적인 데이터 전송이 일어나야하는 통신 형태에 적합
- 가볍기 때문에 호스트의 CPU와 메모리에 대한 부하를 현저하게 줄임(DNS와 같이 불특정 다수에게 서비스를 제공해야하는 특성을 지닌 프로세스에서 TCP 프로토콜을 사용한다면 DNS 서버에 엄청난 부하가 올 수 있음)

### UDP Header

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/30bffdf5-5f2f-4801-ad38-81c8d1b1b1fd/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211218%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211218T095244Z&X-Amz-Expires=86400&X-Amz-Signature=23e02cb26124244f5148d2315ec7eeb932c664a28200809440fd9d545bb5b37c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- source port :
  - 2byte 길이
  - UDP 메시지를 전송한 응용프로그램 프로세스에 대한 위치 정보
  - TCP와 다르게 정보가 입력되지 않아도 됨
- Destination Port
  - 메시지를 전달하려고 하는 목적지 응용프로그램 계층의 프로세스 위치 정보
- Length
  - 2byte 길이
  - UDP 메시지의 전체크기(UDP헤더 + UDP 메시지), UDP 길이의 최소값은 UDP 헤더크기인 8byte고, 최대값은 65.515byte
- checksum
  - 송신 호스트는 UDP 메시지를 전송할 때 헤더 앞에 12byte의 Pseudo Header를 삽입한 후 Checksum값을 연산. 이 UDP 메시지를 수신한 수신한 호스트는 IP 헤더에 명시된 목적지 IP주소를 참조해서 UDP checksum 연산을 함으로써 UDP 데이터그램의 손상여부와 해당 메시지가 올바른 목적지에 도착한 것인지 파악할 수 있음

## TCP

### 신뢰도를 높이기 위해 TCP가 하는 일

1. 부여된 데이터 순서를 보증(시퀀스 번호)
2. 수신 데이터의 오류 존재 여부에 대한 확인(오류 검증)
3. 상대가 확실히 수신했는지 여부 확인(긍정 확인 응답)
4. 수신받지 못한 데이터의 재전송 요청(슬라이딩 윈도우)
5. 상대의 페이스에 맞춘 데이터 전송(흐름제어)
6. 네트워크 혼잡 상황에 따른 송신 속도 조정(혼잡 제어)

### TCP 기능

#### Data Transfer

- 신뢰성이 보장된 데이터 전송방식
- TCP는 데이터를 Byte 단위의 스트림으로 전송하고, 실제 물리적 연결에서 Stream을 세그먼트 단위로 쪼개어 하위 계층으로 전송. 수신 호스트의 TCP는 수신된 세그먼트를 자신의 버퍼에서 순서대로 재조립해 응용프로그램 프로세스에 전달
- 데이터 전송의 흐름을 보장하기 위해서 송신 데이터 byte마다 순서대로 시퀀스 번호를 부여함. 두 호스트의 트랜스포트 서비스가 연결을 성립할 때  수신 호스트에게 초기 시퀀스 번호를 알려주고 수신 호스트는 시퀀스번호를 통해 데이터를 순서대로 조립해 응용프로계층의 프로세스에게 공급
- 수신 호스트를 자신이 데이터를 올바르게 수신했다는 Ack 메시지를 전송. 송신 측은 자신이 전송한 세그먼트가 상대방에 올바르게 도착했음을 확인
- 송신 호스트 쪽은 데이터를 byte 흐름으로 전송하기 때문에 데이터 앞뒤 경계를 표시하기 위해  FUSH Flag를 사용

#### Positive Acknowledgement with retransmission

TCP가 데이터 전송의 신뢰성을 보장하기 위해 사용하는 방법

1. 자신이 송신한 세그먼트의 복사본을 버퍼에 저장해놓고 수신 호스트로부터 송신된 세그먼트를 잘 수신했다는 Ack가 올 때까지 다음 세그먼트를 전송하지 않고 대기
2. 해당 세그먼트 복사본에 타이머를 시작하고 만일 이 타이머가 종료될 때까지 Ack 메시지가 도착하지 않으면 이를 재전송
3. Ack가 오면 복사본을 삭제

#### Flow Control

- 통신에 참가한 두 호스트의 용량 차이에 적절하게 데이터 전송을 조절 : 송신 호스트가 수신 호스트의 버퍼크기와 데이터 처리 능력을 모른 상태로 일방적으로 대용량의 Byte 스트림을 전송할 경우 수신호스트는 이 연결의 통신을 처리하기 위해 자신의 모든 자원을 소진하거나 모든 데이터를 Drop 시키는 결과를 초래
- 네트워크 상황에 맞게 통신량을 조절 : 두 호스트의 논리적 연결 사이에 라우터같은 장비들이 이를 처리하지 못하는 상황이 발생. 네트워크상에서 딜레이가 일어나면 재전송해 패킷이 중복될 수 있고, 오히려 불안정한 네트워크 상태를 악화시킬 수 있음
- 이 문제를 해결하기 위해 연결을 성립하는 과정에서 자신의 버퍼 상황을 상대편 호스트에게 알리고, 데이터 교환과정에서도 자신의 버퍼의 용량에 대해 알림. 버퍼의 크기는 통신의 형태와 양 호스트 자원상황에 맞게 버퍼의 크기와 배치를 동적으로 구성해야함

##### 슬라이딩 윈도우(Sliding Window)

정보프레임을 이동시키는 기법으로 송수신의 진행상태, 누락된 패킷의 재전송, 패킷의 순서 보정 등을 관리

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/08b4d70a-af3e-4750-9925-3c55724cdbd3/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211218%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211218T095414Z&X-Amz-Expires=86400&X-Amz-Signature=222e7a59cd7127606c4da34fae7111bb29fb67c5a53a2bce0c040d92eaa45ef3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- Sent/ACKed Data : 이미 전송된 데이터 중 ACK가 된 데이터 영역. 첫번째 byte의 시퀀스 번호는 항상 초기 시퀀스 번호( ISN)+1
- Sent/UnACKed Data : 이미 전송되었지만 아직 ACK는 안된 영역
- Unsent/Inside Data : 윈도우의 범위안에 들어왔지만 아직 전송되지 않은 부분의 데이터. 일반적인 상황에서는 ACK 상관없이 전송되나 네트워크의 Congestion을 감지했다면 대기하기 때문에 이 영역이 발생함
- Unsent/Outside: 아직 윈도우에 들어오지 않은 데이터 영역

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/13290ac9-8bbb-4bfa-a471-c33fcb1b7d0c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211218%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211218T095446Z&X-Amz-Expires=86400&X-Amz-Signature=d6a0e269e859e30e6744b8cfe062d1ddf030bd49c425c26b12f9714f0711fbdf&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

1. 연결의 초기 성립과정에서 송신 호스트에 대한 Ack 메시지에 수신 호스트는 자신이 수용할 수 있는 데이터 Byte의 양을 시퀀스 번호로 송신 호스트에 알려 송신호스트가 데이터의 양을 조절하도록 함
2. 송신 호스트는 세그먼트를 전송하기 전에 일정한 크기의 윈도우를 두고 이 윈도우 안에 있는 연속된 세그먼트들을 한꺼번에 전송하고 재전송 타이머를 구동
3. 윈도우의 크기는 네트워크 상태에 따라 변경(수신 호스트의 Ack가 도착할 때까지 자신이 전송한 세그먼트 수와 소요된 시간을 근거로 계산)
4. 재전송 타이머가 종료되기 전에 Ack가 오면 윈도우를 오른쪽으로 옮겨가며 다음 세그먼트를 전송
5. 재전송타이머가 종료되면 재전송

#### Multiplexing

TCP는 한 대의 호스트에서 구동 중인 여러 응용프로그램 프로세스가 동시에 TCP 전송 서비스를 사용할 수 있게 하거나, 원격 호스트의 프로세스들이 로컬 시스템의 여러 프로세스들과 동시에 연결을 수립하여 데이터 전송을 할 수 있는 기능을 제공

### TCP Connection Establishment and Termination

#### 3-way Handshake 핸드쉐이크

- TCP 연결 요청이나 응답을 전달하는 IP 서비스가 데이터그램을 신뢰성있게 배달하지 못하는 문제를 해결하기 위해 사용하는 방법

- 3개의 세그먼트를 이용해 연결요청과 이에 대한 응답을 교환하고, 동일한 연결요청(시쿼스 번호가 동일한 연결요청)이 수신되면 무시하여 중복연결 방지

- 양 호스트가 연결을 성립하는 과정에서 주고 받는 정보

  - 연결하고자 하는 목적지 포트와 자신의 송신 포트
  - 데이터 전송시 사용할 초기 시퀀스 번호
  - 수신할 수 있는 최대 세그먼트 사이즈
  - 기타 TCP 옵션

- 접속 방법

  1. 접속하고자 하는 쪽에서 상대에게 SYN패킷(SYN 플래그가 1인 특수 TCP 패킷)보냄
  2. 받은 상대는 SYN+ACK패킷(SYN플래그와 ACK플래그가 1인 특수 TCP패킷)을 되돌려 보냄
  3. 이걸 수신하면 ACK패킷(ACK플래그가 1인 특수 TCP패킷)을 보냄

  이 과정이 정상적으로 이뤄지면 완료됐다고 간주, 이 패킷들은 시퀀스 번호 초기값이 들어있으며 이후 이 값을 사용해서 데이터의 순서 보정 등을 함

- 연결 해제

  1. 연결을 먼저 해제하려는 측에서 FIN패킷을 보냄
  2. 받는 쪽에서 ACK+FIN패킷을 되돌려보냄
  3. 이걸 수신한 후 ACK 패킷을 보냄

  서로 종료 여부에 대해 확인 후 통신을 마침

#### Half Open Connection and SYN Attack

Half Open Connection은 성정적으로 연결이 마무리 되지 못한 상태. 이 연결 요청도 일반적인 데이터 교환과 같이 재전송 타이머를 구동하는데 문제가 발생. 임의의 호스트에서 연속적으로 SYN요청을 전송하고 SYN-ACK에 대한 ACK를 보내지 않으면 이 연결을 유지하기 위해 자신의 메모리 공간을 모두 소진하고, 새로운 연결을 맺을 수 없음. 이러한 특성을 이용해 DoS(Denial Of service)공격을 하는 방식이 SYN 공격.

#### TCP Connection Management

- 일시적인 네트워크 다운 상태가 오더라도 양 호스트의 TCP 서비스의 연결에 대한 유지방법으로 Keepalive을 사용
- 두 호스트의 TCP 연결을 유지시키기 위해 양 호스트의 TCP 프로세스는 일정한 간격에 한번씩 Keep Alive 세그먼트를 교환. 이 KeepAlive 세그먼트에 대한 응답이 상대편으로부터 수신되면 상대편 TCP가 아직 연결에 참가 하고 있다고 판단
- Keepalive 세그먼트로 현재까지 전송한 세그먼트의 시퀀스 번호에서 1을 뺀값을 시퀀스 번호로 설정해 상대 호스트에게 전송 → Keepalive 세그먼트를 수신한 호스트는 이 시퀀스 번호에 1을 더해 ACK 세그먼트를 전송
- 정기적으로 데이터를 교환하는 두 호스트 사이에서 매우 유효한 기능을 제공

### TCP Header Format

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/53743709-988d-41e2-857b-3fd5c42d0130/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211218%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211218T095746Z&X-Amz-Expires=86400&X-Amz-Signature=78d15175994affe8a07d6a01532f31f1f78fd204a7bf7f6dcd2120144ca03a8c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- Source port / Destination Port
  - TCP 논리 연결의 종점, end point를 나타냄. 이 항목에 입력되어 있는 포트번호는 해당 호스트에서 각 애플리케이션 프로세스의 위치 정보를 나타냄
- Sequence Number
  - 데이터 각 byte 마다 부여된 고유한 번호
  - 데이터 스트림의 순서, 중복된 세그먼트에 대한 구분에 대한 기능을 제공
  - SYN Flag가 1로 설정되어 있다면(연결 요청 세그먼트라면) TCP 연결에서 사용할 초기 시퀀스 번호를 의미
- Acknowledgement Number
  - 자신이 몇번째 Byte까지 수신했음을 알리기 위해 송신 호스트에 수신한 시퀀스 번호 사용
- Offset
  - 4bit로 구성된 data offset은 한 bit가 4byte를 나타내어 TCP 헤더의 전체 길이를 표시
- TCP Flag
  - ACK Flag : 이 항목이 1이면 Acknowledgement Number항목에 Ack 번호가 입력되었다는 의미
  - SYN Flag : 이 항목이 1이면 TCP 연결을 위한 요청, 즉 시퀀스 번호를 동기화 하기 위한 세그먼트임을 나타냄, 이 헤더의 Sequence 번호는 초기 시퀀스 번호가 됨
  - FIN Flag : 연결 종료에 대한 요청을 나타냄
  - RST Flag : 특정 에러 혹은 사용자의 명령에 의해 TCP 연결을 재설정하기 위해 사용됨 (Connection Reset). RST 항목이 설정된 세그먼트를 수신한 수신호스트의 TCP는 반드시 연결을 끊어야함. 연결이 종료되면 두 호스트 사이에 송수신되던 데이터가 유실됨
  - PHS Flag : 이 항목이 1로 설정되면 TCP에게 수신된 데이터를 즉시 상위 계층의 프로세스에게 넘겨주라는 것을 의미
  - URG : 이 항목은 현재 Urgent Pointer에 명시된 항목이 기존의 바이트 스트림, 즉 데이터 교환 혹은 어플리케이션 프로세스의 Control을 위해 전송할 메시지 혹은 데이터임을 나타냄. 이 항목이 표시되면 수신 호스트의 TCP는 수신된 기존의 순서에 상관없이 즉시 상위 계층에 올려 처리하도록 함
- Window Size
  - 송신 호스트가 전송한 세그먼트를 수신할 수 있는 여분의 버퍼가 얼마나 남았는가를 표시
  - 송신 호스트는 Window size에 맞춰 데이터 전송량을 결정
- Urgent Pointer
  - Urgent 데이터는 일반적인 데이터 스트림을 통제하거나 데이터 처리 프로세스를 중단하기 위해, 혹은 어플리케이션 계층의 프로토콜간의 비동기 이벤트를 통지하기 위한 목적으로 사용되는 Control data를 말함
  - 통제용 데이터를 전송하는 방법은 크게 두가지로 하나는 Control 메시지를 송수신하기 위한 별도의 연결을 만들어 데이터를 교환(주로 FTP에서 사용), 두번째는 데이터 전송용 연결을 같이 사용하는 방법으로 URG Flag를 1로 표기하고 데이터 위치를 Urgent Pointer로 명시
- Option
  - Maximum Segment Size Option : TCP 연결의 성립과정에서 양 호스트의 최대 세그먼트 크기를 협상하기 위한 기능을 제공
  - Tcp Window Scale Option : TCP 연결의 성립과정에서 양 호스트는 이 옵션을 사용해서 자신의 수신 윈도우 크기를 상대에게 알림
  - Selective Acknowledgment Option: positive acknowledgement 방식은 데이터 전송의 신뢰성을 보장하나 패킷의 유실율이 높은 네트워크에서 데이터 전송의 효율성을 보장하지 않음. 이 문제를 해결하기 위해 나온게 순서대로 도착하지 않은 세그먼트에 대한 ACK를 모두 보낼 수 있는 SACK방법
  - TCP Timestamp Option : 대역폭은 넓지만 지연시간이 많은 위성망 같은 경우 재전송 타이머를 연산하기 어렵고, 불필요한 재전송이 발생. 이 문제를 해결하기 위해 각 세그먼트에timestamp 옵션값을 함께 전송하는 방법. 수신 호스트는 ACK에 해당 timestamp를 그대로 사용해 응답하고, 송신 호스트는 자신에게 돌아온 세그먼트의 Echo replay  값을 통해 해당 세그먼트의 RTT(round-trip time)를 연산할 수 있음

## TCP Acknowledgment(ACK)

- ACK flag 가 설정되어 있는 세그먼트
- ACK 세그먼트에 입력되어 있는 ACK 번호는 수신 호스트의 TCP가 수신한 연속적인 byte stream다음에 올 byte 번호를 나타내어 송신 호스트의 TCP가 자신이 전송한 byte stream의 어느 부분까지 올바르게 수신되었는지를 파악하게 해줌
- SACK 옵션이 활성화 되어 있는 경우, 수신 호스트는 자신에게 수신된 세그먼트가 연속적으로 도착하지 않더라도 수신된 데이터 블록의 상황을 송신 호스트에 알림으로써 효율적인 데이터 전송이 가능하게 함

| UDP                                                          | TCP                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 연결하지 않고 사전 준비없이 바로 통신을 시작. 재전송이나 순서변경 하지않고 바로 애플리케이션으로 넘김 | 먼저 대상끼리 연결하고 통신. 수신한 패킷에 문제가 있거나 일부 패킷이 손실되거나 반대로 패킷이 중복되어 도착하거나, 또는 패킷의 순서가 바뀌면 해당 오류를 해결하기 위한 행동을 취함 |
| 불특정 다수의 클라이언트에 서비스를 제공하고 데이터 양이 매우 작은 단순한 질의 응답 형태인 응용프로그램 프로세스에게 유용 | TCP는 순서를 보장한다는 점과 신뢰도가 있다는 점에서 대부분의 HTTP 통신, 이메일이나 파일전송처럼 순서대로 도착해야 하는 상황에서 사용 |
| TFTP, DNS, SNMP, RIP                                         | HTTP, FTP, E-mail                                            |





# 응용계층

- 애플리케이션 층은 개별 애플리케이션이 갖고 있는 기능을 구현
- 애플리케이션층의 애플리케이션이란 사용자가 사용하는 애플리케이션 이외에 서버가 각종 통신 서비스에 사용하는 프로그램도 포함. 통신기능을 사용하는 프로그램 전체

## 클라이언트 - 서버 구조

일대일 통신이 특징

### 클라이언트

- 클라이언트 응용프로그램이 서버에게 요청(클라이언트 간의 통신 불가능)
- 필요할떄만 작동
- 동적 IP 주소 사용가능

### 서버

- 다수의 클라이언트의 서비스 요청에 응답
- 항상 작동
- 고정 IP주소 사용
- 확장성 문제

## peer to peer

- 통신 단말기를 peer라고 함
- 임의의 호스트간에 직접 통신
- 각 호스트는 클라이언트 역할과 서버 역할을 동시에 수행하기 때문에 호스트 간의 관계가 대등

### 장점

- 서버 의존성이 없음
- 구축 및 관리 비용이 낮음: 서버장치 성능이 낮아지고 통신회선도 저럼하게 할 수 있음
- 자가 확장성 : 클라이언트-서버는 클라이언트 수가 증가할때마다 서버의 처리능력 및 서버에 연결되어있는 네트워크 회선에 부하가 집중되는 반면 P2P방식은 연결하는 사용자 수가 방대해도 부하가 집중되지 않음

### 문제점

- 보안취약성
  - 의도하지 않은 정보의 유출 위험
  - 공유 데이터 삭제 곤란
  - 데이터 변조의 위험
- 낮은 신뢰성
- 낮은 성능 : 현재 빠른 기간 네트워크에서 다수의 느린 서브 네트워크로 분기해 나가는 구조. 클라이언트-서버 주고는 서버를 기간 네트워크에 가급적 가까이에 연결하여 넓은 범위의 클라이언트가 빠르게 서버에 연결할 수 있도록 설계하지만 P2P는 불가능. 또한 일반 가정을 연결하는 인터넷회선은 다운로드보다 업로드가 느리기 때문에 더욱 제약이 큼

### bitTorrent

- 하나의 파일을 chunks로 나누고 peer들은 파일 chunks를 받거나 보낼 수 있음
- peer 목록을 얻기 위해 tracker(peer들을 추적)에 자신을 등록하고 peer 하위 집합에 속하면서 chunk를 업로드 하거나 다운로드 할 수 있음





# 호스트 설정 : DHCP

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2cf1f712-2b1c-4b73-94d5-b026f849dc9e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211218%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211218T100203Z&X-Amz-Expires=86400&X-Amz-Signature=ed66f2218e0d3e66707e2ace408ed0445940a458d57eba8974c730a39e10ed7d&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- 네트워크에 접속되어 있는 컴퓨터에 대해 필요한 네트워크 설정 정보를 자동으로 배포하기 위한 구조
- PC에 DHCP 클라이언트 기능이 탑재되고 네트워크에 DHCP 서버가 설치되야 사용할 수 있음
- DHCP로 설정할 수 있는 주요 정보 : 컴퓨터의 IP주소, 서브넷 마스크, 기본 게이트웨이, DNS서버의 IP 주소 등 컴퓨터가 네트워크에 접속하는 데 필요한 정보 대부분
- 소규모 사무실이나 가정에서 이용하는 대부분의 라우터는 DHCP서버 기능을 갖고 있음

## DHCP 동작의 흐름

DHCP는 컴퓨터에 IP 주소 등의 네트워크 설정이 되어 있지 않은 시점에서 사용하므로 브로드캐스트를 사용해 DHCP 서버와 통신

1. DHCP클라이언트는 DHCP 디스커버 메시지를 브로드 캐스트해 할당 가능 한 주소를 요청(IP주소 호출)
2. DHCP 서버는 수신 후 설정 정보의 후보를 결정하고 DHCP 오퍼 메시지를 반송(MAC 주소를 추출해서 1대1 통신)
3. DHCP 클라이언트는 DHCP요청을 브로드캐스트해 표시된 후보를 사용한다는 사실을 전달
4. 설정정보를 받은 DHCP 서버는 할당이 확정되었다고 판단하고 할당 상황을 기억함과 동시에 DHCP Ack를 클라이언트로 보냄

## DHCP 클라이언트 IP 갱신

1. 서버로부터 IP 주소를 대여받은 클라이언트는 대여기간의 1/2이 되면 초기에 IP 주소 사용에 대한 갱신을 함(unicate)
2. 갱신에 성공하면 IP 대여기간은 다시 초기화가 됨. DHCP request를 서버에 전송했으나 응답이 없는 경우 DHCP 클라이언트는 4, 8, 16초 간격으로 갱신을 3번씩 정기적으로 시도
3. 대여기간의 1/2시점에서 갱신에 실패한 DHCP 클라이언트는 대여기간이 7/8이 되면 rebinding 프로세스를 시작함. DHCP 서버를 찾기 위해 request 메시지를 브로드캐스트로 전송(기존의 IP 주소에 대한 갱신을 할 수 있는 서버가 네트워크에 있는지 파악)
4. DHCP 클라이언트가 재부팅되면 부팅과정 중 IP 주소에 대한 Binding이 될때 클라이언트는 재부팅한 환경에서 IP주소의 신뢰성을 보장하기 위해 DHCP서버를 다시 찾아 이전에 대여한 주소를 계속 사용할 수 있는지 확인
5. DHCP 서버가 문제가 생겨 서버의 응답을 받지 못한 DHCP클라이언트는 자신의 기본 게이트웨이로 Ping 프로세스를 진행. PIng 응답을 받으면 계속 주소를 사용하고, 받지 못하면 IP주소 초기화 과정을 진행





# 도메인 네임 시스템(DNS)

- TCP/IP 네트워크는 IP 주소 대신 컴퓨터에 부여된 명칭인 "도메인 명"을 자주 사용. 도메인 명에서 IP 주소를 찾거나 반대로 IP주소에서 도메인 명을 찾는 것을 이름분석(name resolution)이라하고 이 기능을 DNS가 제공

![img](http://bc.kyobobook.co.kr/crosseditor/binary/images/000090/20170210083946861_R9QV11BR.jpg)

- 특정 서버가 집중적으로 처리를 하는 게 아니라 도메인명의 구조에 따라 몇 개로 분산한 서버(컨텐츠 서버)가 각각 협조해서 이름 분석하는 분산 처리 방식

  ![img](http://bc.kyobobook.co.kr/crosseditor/binary/images/000090/20170210083926576_1PJ2XQ6O.jpg)

- [www.google.com](http://www.google.com) 에서 www은 3단계 도메인, google은 2단계 도메인(SLD), com은 최상위 도메인(TLD)

- ICANN에서 최상위 도메인(TLD : Top Level Domain)을 관리

- 각 TDL는 위임된 관리조직(레지스트리)이 관리(.com/.net은 VeriSign 미국기업이, .kr은 한국인터넷진흥원에서 운영),  레지스트리는 TLD를 관리함과 동시에 DNS를 운영

- 질의 응답에 UDP의 포트 53을 사용하고, 루트 도메인부터 계층을 따라서 질의를 반복

- DNS 서버끼리 정보를 복제하는 영역 전송에는 TCP의 포트 53을 사용

## 이름분석 구조

- 인터넷에 접속한 컴퓨터는 보통 DNS에 접근할 설정(질의처인 DNS 서버의 IP 주소설정)이 되어 있음. 통신대상이 도메인명으로 지정되면 먼저 DNS에 이름분석을 요청하고 대응하는 IP 주소를 받은 후 그 IP주소에 대해 통신을 시작
- DNS를 구성하는 서버는 콘텐츠 서버, 캐시 서버(풀 서비스 리졸버)

## DNS 질의 개념도

1. PC나 서버의 프로그램이 이름분석을 요구
2. PC나 서버에 탑재되어 있는 스터브 리졸버(stub resolver,  DNS 질의 프로그램)가 캐시서버로 이름분석요청을 보냄
3. 캐시서버는 콘텐츠 서버로 접속하여 이름 분석을 하고 그 결과를 스터브 리졸버로 보냄(질의의 각 단계에서 취득한 대응 정보는 캐시라고 불리는 영역에 보존해두고 다음에 동일한 질의가 오면 콘텐츠 서버를 뒤지지 않고 캐시에 보존되어 있는 결과를 사용)
4. 스터브 리졸버는 다시 프로그램으로 되돌려 보냄