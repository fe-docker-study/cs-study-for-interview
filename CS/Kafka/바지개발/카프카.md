# 카프카

![Untitled](https://user-images.githubusercontent.com/90545926/176172000-2f7caf12-1545-478d-9ba5-e793c7d90266.png)

- 아파치 카프카 : 고성능 데이터 파이프라인, 스트리밍 분석, 데이터 통합 및 미션 크리티컬 애플리케이션을 위한 오픈 소스 분산 이벤트 스트리밍 플랫폼(distributed event streaming platform)

- PUB/SUB 모델을 구현

  

## 카프카 도입 배경

### 도입 전

![Untitled](https://user-images.githubusercontent.com/90545926/176171971-8269716d-d0ad-4e0c-8404-cf23452290c1.png)

- 여러 네트워크를 사용하는 환경에서 모든 데이터 변경에 대한 올바른 전달 보장 문제
- 동일한 데이터를 동시에 수정하면서 정확하게 순서를 보장해야하고, 수정된 이벤트들을 정확한 순서대로 아웃바운드 전송하는 문제
- 다양한 클라이언트들의 요구사항을 효율적으로 지원하기 어려운 문제
- 빠른 전송을 위한 클라이언트 또는 대량의 배치 전송을 위한 클라이언트를 지원하기 어려운 문제



### 도입 후

![Untitled](https://user-images.githubusercontent.com/90545926/176171977-0d3a8a81-42da-47af-b9a3-63b13a90dc33.png)

- 빠른 데이터 수집이 가능한 높은 처리량 : 카프카의 응답시간은 밀리초(ms) 단위로 처리

- 이벤트 처리 순서보장으로 구조가 간결해짐

- 중복없는 전송(멱등성: 동일한 작업을 여러 번 수행하더라도 결과가 달라지지 않는 것)

- 자연스러운 백프레셔 핸들링 : 카프카 클라이언트는 pull 방식으로 처리할 수 있는 속도로 데이터를 처리할 수 있음

- 강력한 파티셔닝 : 논리적으로 토픽을 여러개로 나누고, 효과적인 수평확장 가능

- 프로듀서와 컨슈머가 완벽하게 분리된 비동식 방식을 사용해 병목현상을 빠르게 파악

  

## 카프카의 구조



![Untitled](https://user-images.githubusercontent.com/90545926/176171983-c0993d1d-5a70-461b-9b54-06182d7af617.png)

- 프로듀서(Producer) : 카프카로 메시지를 보내는 역할을 하는 클라이언트를 총칭
- 컨슈머(Consumer) : 카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트 총칭
- 브로커(Broker): 카프카 애플리케이션이 설치된 서버 또는 노드를 칭함
- 토픽(Topic) : 카프카는 메시지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 고유 함. 카프카에 전달되는 메시지 스트림의 추상화된 개념. 프로듀서는 특정 토픽에 메시지를 발생하고, 컨슈머는 특정 토픽의 메시지를 구독
- 파티션(Partition) : 병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 말함.

- 메시지(Message) 또는 레코드(Record) : 프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각을 말함.
- 카프카(Kafka) 또는 카프카 클러스터(Kafka cluster) : 아파치 프로젝트 애플리케이션 이름으로 여러 대의 브로커를 구성한 클러스터를 의미. 3대 이상의 브로커로 클러스터를 구성

- 주키퍼(Zookeeper) : 아파치 프로젝트 애플리케이션 이름으로 카프카의 메타데이터(metadata) 관리 및 브로커의 정상 상태 점검(health check)을 담당



## 기존 메시지 시스템과 차이

![Untitled](https://user-images.githubusercontent.com/90545926/176171984-76096ded-4b9d-40a4-bfa1-460b1d43e9d4.png)

![Untitled](https://user-images.githubusercontent.com/90545926/176171986-762f9b2f-3a44-4710-b6a4-b93f7dec5e7a.png)

### 다중 프로듀서, 다중 컨슈머

- 다양한 애플리케이션이 데이터를 주고 받고, 유연한 데이터 생산자/소비자 관계를 구성할 수 있음

### 파일시스템에 저장

- 전통적인 메시징 시스템은 메모리상의 큐에 메시지를 저장하고 컨슈머가 메시지를 읽으면 제거
- 카프카는 메시지를 브로커가 위치한 서버의 파일 시스템에 저장함. 컨슈머는 메시지를 바로 소비하지 않고 언제든지 읽을 수 있음
- 컨슈머에 장애가 생겨도 다시 데이터를 읽을 수 있게 되고, 데이터들을 모았다가 배치처리를 할 수 있음

### 수평적인 확장이 용이하도록 설계됨

- 트래픽이 높아짐면 브로커를 추가해 클러스터를 확장할 수 있음
- 프로듀서도 증가 시킬 수 있음
- 컨슈머 그룹으로 묶고, 컨슈머 그룹에 컨슈머를 추가 할 수 있음. 컨슈머 그룹에 컨슈머가 추가되면 컨슈머의 파티션 소유권이 재분배되는 리밸런스 과정을 거쳐 컨슈머들이 고르게 파티션을 할당 받게 됨
- 토픽의 파티션 개수도 운영 중에 추가 가능

### 고성능

- 범용 메시징 시스템이 지원하는 기능(원자적으로 전달하는 트랜잭션, 컨슈머 소비여부 등등)을 포기하면서 높은 처리량을 갖도록 설계됨. 불필요한 기능을 제외하고 내부적으로 배치처리, 분산처리와 같은 다양한 기법으로 성능을 끌어올림

### 컨슈머 pull 방식

- 기존은 컨슈머에게 데이터를 전달하는 push 방식.

- 카프카는 pull 방식을 사용하면서 컨슈머의 처리량을 브로커가 고려하지 않음.

- 컨슈머는 처리할 수 있는 만큼의 메시지만 브로커에게서 가져가기 때문에 최적의 메시지처리 성능을 갖음

- 메시지를 한번에 처리할 수 있는 배치처리도 간단하게 구현할 수 있고, 압축전송도 사용할 수 있음

  

## 카프카 핵심 개념

### 파티션

![Untitled](https://user-images.githubusercontent.com/90545926/176171990-075aed37-fdd2-4f9a-93c7-caab0593f230.png)

- 하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해 토픽 하나를 여러 개로 나눠 병렬 처리가 가능하게 만든 것
- 프로듀서가 메시지를 특정 토픽에 전송하면 카프카 클러스터는 파티션으로 나누어 관리.
- 메시지 키와 파티셔너를 이용해 특정 파티션으로 메시지를 전송할 수 있지만 기본적으로 프로듀서는 발행한 메시지가 어떤 파티션에 저장되는지 관여하지 않음.
- 각 파티션은 컨트롤러에 의해 카프카 클러스터를 구성하는 브로커에게 분배됨
- 파티션은 늘릴 수 있지만 삭제할 수 없음
- 오프셋 : 특정 파티션으로 전달된 메시지에는 오프셋이라는 숫자가 할당됨. 이 오프셋을 이용해 컨슈머가 메시지를 가져가고, 오프셋을 통해서 메시지의 순서를 보장할 수 있음. 오프셋은 순차적으로 증가하는 숫자형태고 파티션 내에서 유일한 값.

#### 파티션 복제

![Untitled](https://user-images.githubusercontent.com/90545926/176171994-d093bb03-ada1-4786-bc72-a7a3fb25d72d.png)

- 고가용성을 제공하기 위해 파티션 복사본을 유지
- 리플리케이션 팩터Replication Factor로 몇 개의 복사본을 저장할지 토픽 별로 설정할 수 있음.
- 토픽의 리플리케이션 팩터가 N으로 설정 → N개의 파티션 복제본이 생성되고 카프카 브로커가 겹치지 않게 나눠가짐. N개의 리플리카 중 1개는 리더로 선정되어 클라이언트 요청을 담당하고, 나머지는 팔로워가 되어 리더의 변경사항을 따라감.

- 리더의 변경 사항을 따라가는 팔로워는 ISR(In-Sync Replica)를 구성하고 변경사항을 따라자지 못하면 ISR에서 빠짐. 리더 리플리카를 담당하는 브로커에 장애가 생겼을 때  ISR에 속한 리플리카가 새로운 리더로 선정됨

- 파티션의 리더와 팔로워는 다른 브로커에 할당해야 고가용성을 보장할 수 있기 때문에 랙을 식별할 수 있는 정보도 명시할 수 있음

- 리플리케이션 팩터 수가 커지면 안정성은 높아지지만 브로커 리소스를 많이 사용하게 때문에 효율적인 리플리케이션 팩터수를 설정해야함

  

### 세그먼트

![Untitled](https://user-images.githubusercontent.com/90545926/176171995-33bbd10f-69fa-4f34-bb22-f6d965605df9.png)

- 프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장되며, 각 메시지들은 세그먼트라는 로그파일의 형태로 브로커의 로컬 디스크에 저장됨
- 메시지는 정해진 형식에 맞춰 순차적으로 저장되고, 메시지 내용만 저장되는 것이 아니라 메시지의 키, 밸류, 오프셋, 메시지 크기 같은 정보가 함께 저장됨
- 기본적으로 1GB까지 세그먼트 파일이 커지고 일정 시간이 지나면 다시 만듦. 보존기간이 지난 메시지는 세그먼트 파일 단위로 지워짐.
- 카프카는 세그먼트 파일을 쓰는 동작에서 별도의 버퍼캐시를 구현하는 대신 운영체제의 페이지 캐시를 사용(운영체제는 사용자가 요청하지 않아도 미리 읽기 동작을 통해 읽을 가능성이 있는 내용을 미리 읽어들이는 최적화를 진행, 버퍼캐시를 운영하지 않기 때문에 JVM에 발생할 수 있는 가비지 컬렉션의 오버헤드도 줄임)



### 프로듀서

- 메시지를 생성하는 클라이언트
- 특정 토픽에 메시지를 전송하면 기본적으로 여러 파티션에 번갈아 전송되어 파티션을 골고루 사용
- 서로 다른 파티션으로 전송된 메시지의 소비순서는 보장되지 않음
- 전송순서가 준요한 메시지는 메시지에 키값을 할당하고 특정 파티션에 전송되도록 파티셔너를 작성할 수 있음

#### 중복없는 전송

ack : 카프카 프로듀서의 프로퍼티로 메시지의 유실가능성과 연관

- ack = 0 : 프로듀서는 전송만 하고 응답을 기다리지 않음, 일부 메시지 손실을 감안하더라도 매우 빠르게 전송이 필요한 경우 사용.

  ![https://sungjk.github.io/images/2021/01/23/producer-acks-1.png](https://sungjk.github.io/images/2021/01/23/producer-acks-1.png)

- ack=1 프로듀서는 리더 리플리카를 가지고 있는 브로커의 응답만 기다림. 메시지 손실 가능성이 적고 적당한 속도의 전송이 필요한 경우 사용.

![https://sungjk.github.io/images/2021/01/23/producer-acks-all.png](https://sungjk.github.io/images/2021/01/23/producer-acks-all.png)

- ack=all(-1) : 프로듀서는 ISR를 구성하는 리플리카들이 메시지를 복사해 갈때까지 기다림(브로커의 프로퍼티 중 min.insync.replia에 명시된 숫자의 리플리카가 복제된 경우) 전송 속도는 느리지만 메시지 손실이 없어야 하는 경우 사용.
- ack=0의 경우 리더 리플리카 브로커에 장애가 발생하면 메시지가 유실 될 수 있고, ack=1은 리플리카가 메시지를 복사하지 못한 상태에서 리더 리플리카에 장애가 발생하면 메시지가 유실될 수 있음.



### 컨슈머

![Untitled](https://user-images.githubusercontent.com/90545926/176171997-c5bc23b1-1369-47b2-ad87-d33e4b18a453.png)

- 메시지를 읽는 클라이언트

- 컨슈머 그룹을 형성하고, 카프카의 토픽은 컨슈머 그룹단위로 구독됨

- 토픽의 파티션은 컨슈머 그룹당 하나의 컨슈머만 소비할 수 있음(파티션 내의 순서보장)

- 컨슈머는 오직 파티션의 오프셋 기준으로만 메시지를 가지고 옴. 컨슈머 그룹은 각각의 파티션에서 자신이 가져간 메시지 위치정보인 오프셋을 기록하고, 각 파티션에 대해 현재 위치를 업데이트 하는 동작을 커밋이라함

- 파티션과 컨슈머의 소유권 관계는 브로커와 컨슈머 구성이 변경되지 않으면 계속 유지되고, 변경된 경우 컨슈머 그룹내에서 파티션의 소유권을 재분배하는 리밸런싱 과정이 실행됨

- 컨슈머 그룹의 컨슈머 수가 토픽의 파티션보다 많은 경우 잉여 컨슈머가 발생하지 때문에 파티션 개수보다 컨슈머 개수는 적어야함

- 컨슈머 그룹은 각 파티션에 대한 오프셋 값을 할당받고, 이 오프셋으로 컨슈머 그룹이 해당 파티션에서 어디까지 읽었는지 알 수 있음

- 다중 컨슈머 그룹을 지원하고, 컨슈머 그룹단위로 독립적으로 데이터를 처리함

  

### 컨트롤러

- 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하게 됨
- 파티션의 ISR 리스트 중에서 리더를 선출(ISR 리스트 정보는 주키퍼에 저장)
- 컨트롤러는 브로커가 실패하는 것을 항상 체크하고 브로커의 실패가 감지되면 즉시 ISR 리스트 중 하나를 새로운 파티션 리더로 선출하고 리더의 정보를 주키퍼에 기록하고 변경된 정보를 모든 브로커에게 전달
- 파티션의 리더가 다운되면 해당 파티션으로 모든 읽기/쓰기가 실패하게 되고 클라이언트에 설정값에 따라 재시도하고, 재시도 시간 내에 리더 선출 작업이 빠르게 이뤄짐