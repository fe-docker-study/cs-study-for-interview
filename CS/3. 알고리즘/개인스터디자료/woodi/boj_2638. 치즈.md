```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/**
 * 초기화 : 가장 자리 공기 = 진짜 공기
 * 값이 0 일 때, 2가지 경우 존재
 * 1. 진짜 공기 : 진짜 공기와 적어도 한 변 이상 닿아있음
 * 2. 가짜 공기 : 단 한 면도 진짜 공기와 닿아 있지 않음 (치즈 안에 갇혀있음)
 * 
 * pq <- 진짜 공기
 * pq.poll -> 진짜 공기
 * 좌우위아래 
 * 	0 : 큐에 추가 (가짜공기가 진짜 공기가 됨) 
 * 	1 : 0으로 변경 (치즈가 녹음), 최종 녹은 시간 비교 & 업데이트, 큐에 추가 (진짜 공기가 됨)
 *  
 *
 */
public class Main {
	static class Pair implements Comparable<Pair>{
		int x;
		int y;
		int val;
		int time;
		boolean visited;
		int count;
		
		public Pair(int x, int y, int val, int time) {
			this.x = x;
			this.y = y;
			this.val = val;
			this.time = time;
			this.visited = false;
			this.count = 0;
		}

		@Override
		public int compareTo(Pair o) {
			return this.time - o.time;
		}
	}
	static int n;
	static int m;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		int[] dx = {1,-1,0,0};
		int[] dy = {0,0,1,-1};
		
		n = Integer.parseInt(st.nextToken());
		m = Integer.parseInt(st.nextToken());
		
		Pair[][] map = new Pair[n][m];
		PriorityQueue<Pair> pq = new PriorityQueue<>();
		
		for(int i=0; i<n; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j=0; j<m; j++) {
				int val = Integer.parseInt(st.nextToken());
				map[i][j] = new Pair(i,j, val, 0); 
				if(i==0 || j==0 || i==n-1 || j==m-1) {
					pq.add(map[i][j]);
					map[i][j].visited = true;
				}
			}
		}
		
		// bfs
		int result = -1;
		while(!pq.isEmpty()) {
			Pair now = pq.remove();
			
			for(int i=0; i<4; i++) {
				int nx = now.x + dx[i];
				int ny = now.y + dy[i];
				if(!isOutOfBound(nx, ny) && map[nx][ny].visited==false) {
					if(map[nx][ny].val == 0) {	// 가짜 공기 
						map[nx][ny].visited = true;
						map[nx][ny].time = now.time;
						pq.add(map[nx][ny]);
//						result = Math.max(result, now.time+1);
					}else {	// 치즈 : 진짜 공기에 두번 이상 닿으면 녹음 
						if(map[nx][ny].count==1) {
							map[nx][ny].visited = true;
							map[nx][ny].time = now.time+1;
							pq.add(map[nx][ny]);
							result = Math.max(result, now.time+1);
						}else if(map[nx][ny].count==0){
							map[nx][ny].count++;
						}
					}
				}
			}
		}
		
		System.out.println(result);
		
	}
	
	public static boolean isOutOfBound(int x, int y) {
		if(x<0 || x>=n || y<0 || y>=m) return true;
		return false;
	}
}




```
