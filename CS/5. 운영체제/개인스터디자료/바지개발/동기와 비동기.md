# 동기와 비동기

## Synchronous/Asynchronous

- 작업을 수행하는 주체에 대한 관점
- 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 포인트

### Synchronous

- 두개 이상의 주체가 작업 시간을 똑같이 맞춤
- 설계가 매우 간단하고 직관적
- 결과가 올때까지 다른 작업을 못하고 대기
- 시스템의 반환을 기다리는 동안 waiting queue에 머무는 것이 필수가 아님, 호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경쓰면 synchronous

### Asynchronous

- 두개 이상의 주체가 작업 시간을 서로 맞추지 않음

- 동기보다 복잡함

- 결과가 주어지는데 시간이 걸리더라도 다른 작업을 할 수 있으므로 자원을 효율적으로 사용

- system call이 반환될 때 실행된 결과와 함께 반환될 경우, 호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 Asynchronous

  

## Blocking/Non-Blocking

- 제어권이 어디에 있는지에 대한 관점 : 작업을 시킨 주체에게 제어권이 있는지 혹은 작업을 처리하는 주체에게 제어권이 있는지에 대한 것
- 호출되는 함수가 바로 리턴하느냐 마느냐가 포인트

### Blocking

- 직접 제어할 수 없는 대상의 작업이 끝날 때까지 기다려야 하는 경우
- 시스템의 반환을 기다리는 동안 waiting queue에 머무는 것이 필수, 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만들면 blocking

### Non-Blocking

직접 제어할 수 없는 대상의 작업이 완료되기 전에 제어권을 넘겨주는 경우



## Critical Section(임계구역 또는 공유변수 영역)

- 병렬프로그래밍에서 둘 이상의 스레드 (멀티스레드)가 동시에 접근해서는 안되는 공유 자원(파일, 입출력, 공유 데이터 등) 을 접근하는 명령문 또는 코드의 일부 영역

- 병렬프로그래밍에서 A라는 스레드가 공유 데이터의 값 변경을 시도하는 순간 B라는 스레드가 그 값을 읽는다면 그 값이 변경된 값인지 변경되기 전 값인지 예측할 수 없음. 이러한 문제로 동기화 처리 (synchronized)를 반드시 해줘야하며, 임계구역에 실행되는 스레드는 lock을 획득하게 되는데 이 lock은 오직 하나의 스레드만 가질 수 있음

  

### 임계 구역 문제를 해결하기 위한 조건

#### 상호 배제 (mutual exclusion)

하나의 프로세스가 임계 구역에서 실행되고 있다면, 다른 프로세스들은 임계 구역에서 실행될 수 없음

#### 진행 (progress)

임계 구역에 실행되고 있는 프로세스가 없을 경우, 들어갈 프로세스를 적절히 선택해야 함

#### 한정된 대기 (bounded waiting)

프로세스의 기아를 방지하기 위해, 한번 임계 구역에서 실행된 프로세스는 다음 실행에 대한 제한을 둬야 함