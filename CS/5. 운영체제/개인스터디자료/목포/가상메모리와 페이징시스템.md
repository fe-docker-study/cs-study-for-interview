## 가상 메모리

가상메모리란 실제 각 프로세스마다 충분한 메모리를 할당하기에 한계가 있어 생긴 개념으로 어느 시점에 한 프로세스를 사용할 때 해당 부분만 메모리에 올린다.(전체 프로세스 데이터를 특정 시간에 일부분만 참조한다.) 그래서 실제 메모리보다 메모리 공간이 많이 보이게 또, 그렇게 사용할 수 있다.

때문에 여러 프로세스가 동시에 실행되는 환경에서 필요하다.

결국 프로세스는 가상 주소를 사용하고 실제 해당 주소에서 읽고/쓸때만 물리주소로 바꿔주면 되는 것.

    * virtual address (가상 주소) : 프로세스가 참조하는 주소
    * physical address(물리 주소) : 실제 메모리 주소

cpu가 특정 프로세스에 공간을 참조할 때는 가상 주소를 먼저 찾게되고 실제 물리 주소에 매핑이 되어있는지 알아야하기 때문에 이를 변환해주는 메커니즘이 가상 메모리 시스템 안에 들어있다.

이 변환 과정의 시간을 짧게하기 위해 MMU(Memory Management Unit)을 탑재해 지원한다.

CPU는 가상메모리 주소를 참조해달라 요청하고 그 가상 주소가 어느 물리 주소에 있는지 MMU가 변환하여 처리하고 해당 데이터를 CPU에 전달한다.

### 페이징 시스템

크기가 동일한 페이지로 가상 주소공간과 이에 매칭되는 물리 주소 공간을 관리한다
Intel x86 시스템(32bit)의 경우 페이징 사이즈를 4KB, 2MB, 1GB 지원한다. 리눅스의 경우에는 4KB로 페이징 단위를 다루고 있다.

#### 동작 방식

프로세스의 상태정보를 관리하는 PCB 에는 Page Table 구조체를 가리키는 주소가 들어있다. Page Table은 가상 주소와 물리 주소간 매핑 정보가 있다.
CPU가 가상 주소에 접근 시 가상주소는 어떤 페이지 번호인지 해당 주소를 보고 알 수 있다. 그 후 PCB의 Page Table에 들어가 물리 주소를 알아낸 후 데이터를 가져온다.

#### 구조

page 또는 page frame은 고정된 크기인 4kb의 block을 가진다.
가상 주소 v (32bit)는 가상 메모리 페이지 번호(p)와 변위(d)의 값을 가진다. 그래서 페이지 크기가 4kb 일 때 가상 주소의 0비트에서 11비트는 변위를 나타내고 12비트 이상의 페이지 번호가 될 수 있다.

#### 페이지 테이블

[image:D7A4EC53-9073-4EE6-B3EB-505A003E6E55-1154-0000002CA5CE007E/0465A3B2-4A84-4D66-82A9-A69D19B0193A.png]
물리 주소에 있는 페이지번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표이다.
해당 프로세스의 page table base 주소는 pcb에 저장되어있으며 페이지 번호만 알면 해당 page까지 넘어갈 수 있다. 그렇게 찾아낸 물리주소와 변위를 더하면 실제 물리주소가 된다.

[image:297E8BA5-196B-4BD1-B9DD-27142FA23692-1154-00000038976F785F/B9F9D22B-6794-4A52-9DD4-3619C715681A.png]

### 페이징 시스템과 공유메모리

물리 주소에 데이터 수정 시 비로소 프로세스가 복사가된다.

    * 프로세스의 생성 시간이 짧아진다.
    * 커널, 공유메모리든 공유데이터는 물리 메모리의 공간이 공유가 가능하게된다.

[image:AEFBFFDD-824C-4B52-B3EA-F5C177A09508-1154-0000003B9F2B3D2D/DEC773E3-CE7C-442B-AFCE-E18243822350.png]

### 페이지 폴트

어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트.

[image:6B942D0B-FDEC-4E03-B084-B4DCBF2EAE98-1154-00000040F3A3DA2D/8901E71B-4089-4295-867A-443AA9C1D920.png]

만약 페이지 폴트가 자주 일어나게 되면 시간이 오래 걸리게된다.

## 페이징 교체 알고리즘

    * FIFO
    	* 가장 먼저 들어온 페이지를 내린다.
    * 최적 페이지 교체 알고리즘(OPT)

[image:F07D9F85-EFCE-4BAE-8F30-F67FD7A01BAA-1154-00000044031D964B/E70CF7AC-BA72-4614-9F87-3CAB3F83192E.png]

    	* 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다. 일반 OS에서는 구현이 불가하다.
    * **LRU(Least Recently Used)**

[image:39C53E52-A3D5-4B15-9D72-3216152B0249-1154-0000004429B169B5/A3BCE98D-F1EF-4307-A97A-E822AB4E926E.png]

    	* 가장 오래전에 사용된 페이지를 교체
    * LFU(페이지 스왑 알고리즘)
    	* 가장 적게 사용된 페이지를 교체
    * NUR
    	* 각 페이지마다 참조비트(R), 수정(M) (R,M) 를 두어 (0, 0), (0, 1), (1, 0), (1, 1) 순으로 페이지 교체

[image:65D7733C-F9B4-4EBC-BDA1-2EF8CA6A6251-1154-00000044FA84C5BB/88D86213-EFAA-4630-B060-B20818941067.png]
