## 가상 메모리

가상메모리란 실제 각 프로세스마다 충분한 메모리를 할당하기에 한계가 있어 생긴 개념으로 어느 시점에 한 프로세스를 사용할 때 해당 부분만 메모리에 올린다.(전체 프로세스 데이터를 특정 시간에 일부분만 참조한다.) 그래서 실제 메모리보다 메모리 공간이 많이 보이게 또, 그렇게 사용할 수 있다.

때문에 여러 프로세스가 동시에 실행되는 환경에서 필요하다.

결국 프로세스는 가상 주소를 사용하고 실제 해당 주소에서 읽고/쓸때만 물리주소로 바꿔주면 되는 것.

* virtual address (가상 주소) : 프로세스가 참조하는 주소
* physical address(물리 주소) : 실제 메모리 주소

cpu가 특정 프로세스에 공간을 참조할 때는 가상 주소를 먼저 찾게되고 실제 물리 주소에 매핑이 되어있는지 알아야하기 때문에 이를 변환해주는 메커니즘이 가상 메모리 시스템 안에 들어있다.

이 변환 과정의 시간을 짧게하기 위해 MMU(Memory Management Unit)을 탑재해 지원한다.

CPU는 가상메모리 주소를 참조해달라 요청하고 그 가상 주소가 어느 물리 주소에 있는지 MMU가 변환하여 처리하고 해당 데이터를 CPU에 전달한다.

### 페이징 시스템

크기가 동일한 페이지로 가상 주소공간과 이에 매칭되는 물리 주소 공간을 관리한다
Intel x86 시스템(32bit)의 경우 페이징 사이즈를 4KB, 2MB, 1GB 지원한다. 리눅스의 경우에는 4KB로 페이징 단위를 다루고 있다.

#### 동작 방식

프로세스의 상태정보를 관리하는 PCB 에는 Page Table 구조체를 가리키는 주소가 들어있다. Page Table은 가상 주소와 물리 주소간 매핑 정보가 있다.
CPU가 가상 주소에 접근 시 가상주소는 어떤 페이지 번호인지 해당 주소를 보고 알 수 있다. 그 후 PCB의 Page Table에 들어가 물리 주소를 알아낸 후 데이터를 가져온다.

#### 구조

page 또는 page frame은 고정된 크기인 4kb의 block을 가진다.
가상 주소 v (32bit)는 가상 메모리 페이지 번호(p)와 변위(d)의 값을 가진다. 그래서 페이지 크기가 4kb 일 때 가상 주소의 0비트에서 11비트는 변위를 나타내고 12비트 이상의 페이지 번호가 될 수 있다.

#### 페이지 테이블

![0465A3B2-4A84-4D66-82A9-A69D19B0193A](https://user-images.githubusercontent.com/31172248/151791342-62ba36b7-c7e6-4000-af70-1fd39092839d.png)
물리 주소에 있는 페이지번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표이다.
해당 프로세스의 page table base 주소는 pcb에 저장되어있으며 페이지 번호만 알면 해당 page까지 넘어갈 수 있다. 그렇게 찾아낸 물리주소와 변위를 더하면 실제 물리주소가 된다.

![B9F9D22B-6794-4A52-9DD4-3619C715681A](https://user-images.githubusercontent.com/31172248/151791359-817a0117-3835-4453-ab3e-c5cd73b0e3c3.png)

### 페이징 시스템과 공유메모리

물리 주소에 데이터 수정 시 비로소 프로세스가 복사가된다.

* 프로세스의 생성 시간이 짧아진다.
* 커널, 공유메모리든 공유데이터는 물리 메모리의 공간이 공유가 가능하게된다.

![DEC773E3-CE7C-442B-AFCE-E18243822350](https://user-images.githubusercontent.com/31172248/151791380-48677abc-2eaa-4294-af6b-386ac9727b83.png)

### 페이지 폴트

어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트.

![8901E71B-4089-4295-867A-443AA9C1D920](https://user-images.githubusercontent.com/31172248/151791395-a42b30f9-4fa4-4d46-a89c-a624da1c9b9e.png)

만약 페이지 폴트가 자주 일어나게 되면 시간이 오래 걸리게된다.

## 페이징 교체 알고리즘

* FIFO
   * 가장 먼저 들어온 페이지를 내린다.
* 최적 페이지 교체 알고리즘(OPT)

![E70CF7AC-BA72-4614-9F87-3CAB3F83192E](https://user-images.githubusercontent.com/31172248/151791417-0169cb11-bdcb-4853-bc42-39f6513acd70.png)

   * 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다. 일반 OS에서는 구현이 불가하다.
* **LRU(Least Recently Used)**

![A3BCE98D-F1EF-4307-A97A-E822AB4E926E](https://user-images.githubusercontent.com/31172248/151791429-ba096690-2b26-4fd6-a2de-ea47c1d93f3c.png)

   * 가장 오래전에 사용된 페이지를 교체
* LFU(페이지 스왑 알고리즘)
   * 가장 적게 사용된 페이지를 교체
* NUR
   * 각 페이지마다 참조비트(R), 수정(M) (R,M) 를 두어 (0, 0), (0, 1), (1, 0), (1, 1) 순으로 페이지 교체

![88D86213-EFAA-4630-B060-B20818941067](https://user-images.githubusercontent.com/31172248/151791439-d12f0e1d-96a7-4463-9881-c72fb224aa3d.png)
